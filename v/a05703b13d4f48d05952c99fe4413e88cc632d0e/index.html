<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="hr-HR" xml:lang="hr-HR">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="John Doe" />
  <meta name="author" content="Jane Roe" />
  <meta name="dcterms.date" content="2019-12-05" />
  <meta name="keywords" content="mozak, umg, električni potencijal, svjesno biće" />
  <title>MOZAK I UM: OD ELEKTRIČNIH POTENCIJALA DO SVJESNOG BIĆA</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <!--
  Manubot generated metadata rendered from header-includes-template.html.
  Suggest improvements at https://github.com/manubot/manubot/blob/master/manubot/process/header-includes-template.html
  -->
  <meta name="dc.format" content="text/html" />
  <meta name="dc.title" content="MOZAK I UM: OD ELEKTRIČNIH POTENCIJALA DO SVJESNOG BIĆA" />
  <meta name="citation_title" content="MOZAK I UM: OD ELEKTRIČNIH POTENCIJALA DO SVJESNOG BIĆA" />
  <meta property="og:title" content="MOZAK I UM: OD ELEKTRIČNIH POTENCIJALA DO SVJESNOG BIĆA" />
  <meta property="twitter:title" content="MOZAK I UM: OD ELEKTRIČNIH POTENCIJALA DO SVJESNOG BIĆA" />
  <meta name="dc.date" content="2019-12-05" />
  <meta name="citation_publication_date" content="2019-12-05" />
  <meta name="dc.language" content="hr-HR" />
  <meta name="citation_language" content="hr-HR" />
  <meta name="dc.relation.ispartof" content="Manubot" />
  <meta name="dc.publisher" content="Manubot" />
  <meta name="citation_journal_title" content="Manubot" />
  <meta name="citation_technical_report_institution" content="Manubot" />
  <meta name="citation_author" content="John Doe" />
  <meta name="citation_author_institution" content="Department of Something, University of Whatever" />
  <meta name="citation_author_orcid" content="XXXX-XXXX-XXXX-XXXX" />
  <meta name="twitter:creator" content="@johndoe" />
  <meta name="citation_author" content="Jane Roe" />
  <meta name="citation_author_institution" content="Department of Something, University of Whatever" />
  <meta name="citation_author_institution" content="Department of Whatever, University of Something" />
  <meta name="citation_author_orcid" content="XXXX-XXXX-XXXX-XXXX" />
  <link rel="canonical" href="https://fpehar.github.io/manupsy/" />
  <meta property="og:url" content="https://fpehar.github.io/manupsy/" />
  <meta property="twitter:url" content="https://fpehar.github.io/manupsy/" />
  <meta name="citation_fulltext_html_url" content="https://fpehar.github.io/manupsy/" />
  <meta name="citation_pdf_url" content="https://fpehar.github.io/manupsy/manuscript.pdf" />
  <link rel="alternate" type="application/pdf" href="https://fpehar.github.io/manupsy/manuscript.pdf" /> <link rel="alternate" type="text/html" href="https://fpehar.github.io/manupsy/v/a05703b13d4f48d05952c99fe4413e88cc632d0e/" />
  <meta name="manubot_html_url_versioned" content="https://fpehar.github.io/manupsy/v/a05703b13d4f48d05952c99fe4413e88cc632d0e/" />
  <meta name="manubot_pdf_url_versioned" content="https://fpehar.github.io/manupsy/v/a05703b13d4f48d05952c99fe4413e88cc632d0e/manuscript.pdf" />
  <meta property="og:type" content="article" />
  <meta property="twitter:card" content="summary_large_image" />
  <link rel="icon" type="image/png" sizes="192x192" href="https://manubot.org/favicon-192x192.png" /> <link rel="mask-icon" href="https://manubot.org/safari-pinned-tab.svg" color="#ad1457" />
  <meta name="theme-color" content="#ad1457" />
  <!-- end Manubot generated metadata -->
</head>
<body>
<header id="title-block-header">
<h1 class="title">MOZAK I UM: OD ELEKTRIČNIH POTENCIJALA DO SVJESNOG BIĆA</h1>
</header>
<p><small><em> This manuscript (<a href="https://fpehar.github.io/manupsy/v/a05703b13d4f48d05952c99fe4413e88cc632d0e/">permalink</a>) was automatically generated from <a href="https://github.com/fpehar/manupsy/tree/a05703b13d4f48d05952c99fe4413e88cc632d0e">fpehar/manupsy@a05703b</a> on December 5, 2019. </em></small></p>
<h2 id="authors">Authors</h2>
<ul>
<li><p><strong>John Doe</strong><br> <img src="images/orcid.svg" class="inline_icon" alt="ORCID icon" /> <a href="https://orcid.org/XXXX-XXXX-XXXX-XXXX">XXXX-XXXX-XXXX-XXXX</a> · <img src="images/github.svg" class="inline_icon" alt="GitHub icon" /> <a href="https://github.com/johndoe">johndoe</a> · <img src="images/twitter.svg" class="inline_icon" alt="Twitter icon" /> <a href="https://twitter.com/johndoe">johndoe</a><br> <small> Department of Something, University of Whatever · Funded by Grant XXXXXXXX </small></p></li>
<li><p><strong>Jane Roe</strong><br> <img src="images/orcid.svg" class="inline_icon" alt="ORCID icon" /> <a href="https://orcid.org/XXXX-XXXX-XXXX-XXXX">XXXX-XXXX-XXXX-XXXX</a> · <img src="images/github.svg" class="inline_icon" alt="GitHub icon" /> <a href="https://github.com/janeroe">janeroe</a><br> <small> Department of Something, University of Whatever; Department of Whatever, University of Something </small></p></li>
</ul>
<h2 id="predgovor">Predgovor</h2>
<p>U trenutku pisanja ovog predgovora početak je 2019. godine i prošla su dva desetljeća od završetka <em>desetljeća mozga</em>, a istraživanja u neuroznanosti sve su zanimljivija. Primjerice, Nobelova nagrada iz fiziologije i medicine za 2014. godinu dodijeljena je za neuroznanstveno <em>otkriće stanica u mozgu koje sačinjavaju sustav pozicioniranja</em>. Nagradu su podijelili znanstvenici John O’Keefe, May-Britt Moser i Edvard I. Moser. Postoje i brojne druge spoznaje do kojih se došlo u dvijetisućitima. Primjerice, otkriće zrcalnih neurona s kraja prošlog stoljeća intenziviralo je daljnja istraživanja i razumijevanje njihove uloge u ovom stoljeću. Može se reći da su teme o mozgu doista neiscrpne. Istraživanja razlika muškog i ženskog mozga još su uvijek aktualna, s tim da novija istraživanja potvrđuju da su razlike među spolovima manje nego što se nekad mislilo. U fokusu su znanstvenih istraživanja i pitanja kako se motivacija manifestira na neuronskoj razini, tj. u snazi sinaptičkih veza među neuronima. Prisutnost alfa-valova tijekom meditiranja se, prema rezultatima recentnijih istraživanja, povezuje s mentalnom dobrobiti. Konkretnije, povećanje udjela alfa-valova povezano je s kreativnim mišljenjem i reduciranjem depresije. Fizička aktivnost također je povezana s funkcioniranjem mozga. Točnije, poboljšanja su vidljiva u samom zdravlju mozga, ali i u povećanoj kognitivnoj fleksibilnosti kod starijih osoba zbog bolje integracije bijele tvari, odnosno neuronskih vlakana. Većina navedenih spoznaja iznimno je važna u neuroznanosti i medicini, ali i u drugim područjima, primjerice u psihologiji, pedagogiji, filozofiji i kognitivnim znanostima općenito. Istraživanja mozga toliko su uznapredovala da danas nema ni jedne teme u suvremenoj psihologiji o kojoj se ne bi mogla pronaći barem djelomična neuronska osnova koja daje suvisla i detaljna objašnjenja za opisane psihološke fenomene. Stoga je danas više nego prije potrebno da suvremeni studiji psihologije integriraju spoznaje iz područja neuroznanosti u većinu kolegija. Isto bi se moglo preporučiti i drugim društvenim i humanističkim studijima poput filozofije, sociologije i pedagogije. U stjecanju znanja za studente psihologije više nije dovoljno da na samom početku studija dobiju uvid u osnovne spoznaje o građi i funkcijama živčanog sustava unutar kolegija koji se nekad zvao fiziološka psihologija (danas biološka psihologija) te da se nakon toga u ponekim kolegijima tijekom daljnjeg studiranja doziva takvo znanje. Spoznaje iz psihologije danas bi se ipak trebale proučavati višerazinski, kako na razini opažljivih fenomena u doživljavanju i ponašanju tako i na razni funkcioniranja živčanog sustava. Razvoj psihologije i neuroznanosti u budućnosti će se sve više preklapati, a navedeno se odnosi ne samo na bazičnu psihologijsku znanost unutar koje je takva integracija uspostavljena već i na primijenjenu psihologiju. Kako bi se nastavnici i studenti na studiju psihologije, ali i na drugim već spomenutim studijima, uhvatili u koštac s takvim izazovima, na raspolaganju su im brojni udžbenici iz osnova neuroznanosti od kojih su mnogi izvrsni. Svakom studentu psihologije preporučili bismo da što prije pročita barem jedan od takvih udžbenika u cjelini. Međutim, suvremeni trendovi optimizacije nastavnog procesa ograničavaju maksimalnu količinu gradiva na svakom kolegiju, što u konačnici može dovesti do problema s upotrebom jako detaljnih udžbenika. Mnogi od udžbenika iz neuroznanosti preglomazni su i predetaljni i kao takvi više su namijenjeni studentima medicine i neuroznanosti nego studentima psihologije. Naime, takvi udžbenici pokrivaju gotovo sve teme koje se tiču mozga, a za određeni kolegij u studiju psihologije bitno je tek nekoliko tema. Takva razina detaljnosti može biti za studenta demotivirajuća i stoga se javila ideja o izboru odabranih tema iz neuroznanosti koje su korisne i zanimljive studentima psihologije, a vjerojatno i drugim studentima iz područja društvenih znanosti i humanistike. Cilj nam je stoga bio prikazati odabir istaknutih tema koje se danas izučavaju u psihologiji i neuroznanosti s naglaskom na rezultate novijih istraživanja, od kojih jedan dio proizlazi i iz primjene suvremenih tehnika oslikavanja mozga. Knjigu čini deset poglavlja. Prvo poglavlje bavi se živčanim sustavom, funkcijama različitih područja središnjeg živčanog sustava i obogaćeno je prikazima poznatih studija slučajeva ljudi s različitim oštećenjima mozga. U drugom poglavlju prikazana je elektroencefalografija kao jedna od najčešće korištenih metoda u proučavanju mozgovnih procesa. Treće poglavlje bavi se evolucijom mozga. U tom poglavlju čitatelj će se susresti s odgovorima na pitanje smanjuje li se mozak modernog čovjeka i koji bi mogli biti razlozi tomu. Četvrto poglavlje bavi se jednim od najtvrdokornijih neuromitova, mitom o 10 % iskorištenog mozga. Čitatelj ima priliku doznati kako je nastao mit, zašto ljudi vjeruju u psihološke i neuromitove općenito kao i specifično u ovaj mit. U poglavlju su također detaljno izloženi argumenti koji ga pobijaju. Vid je najvažnije ljudsko osjetilo i oko 80 % naših svakodnevnih aktivnosti posredovano je upravo njime. Peto poglavlje donosi informacije kako funkcionira prostorni vid, koji su drugi zadatci vidnog sustava te u kojim se sve područjima mozga obrađuju vidne informacije. Šesto poglavlje uvodi čitatelja u područja mozga koja sudjeluju u deklarativnom pamćenju, prikaze studija slučajeva te suvremena istraživanja pamćenja koja se temelje na tehnikama vizualizacije ljudskog mozga. Sedmo poglavlje bavi se jezikom, dijelovima mozga koji procesiraju jezičnu informaciju, afazijama, načinima ispitivanja lokalizacije jezičnih funkcija te kako učenje stranog jezika utječe na mozgovne strukture. Osmo poglavlje bavi se fenomenom svijesti. Čitatelju pruža uvid u načine istraživanja svijesti, njezina opća obilježja i neuronske korelate. Deveto poglavlje posvećeno je mozgovnim procesima, hormonima i neuroprijenosnicima koji su uključeni u različite aspekte ljudske seksualnosti. To poglavlje pruža uvid u suvremena istraživanja neurokemijskih procesa koji se događaju u različitim stadijima romantične ljubavi: stadij požude i privlačnosti, stadij zaljubljenosti, stadij privrženosti i stadij prekida ljubavnog odnosa. Deseto poglavlje daje pregled istraživanja iz područja političke neuroznanosti. Radi se o mladoj znanstvenoj disciplini koja posljednjih desetak godina učvršćuje svoju poziciju u znanosti.</p>
<p>Knjiga je zamišljena kao dodatni udžbenik za veći broj kolegija na studiju psihologije. Kao takva trebala bi proširiti znanja studenata u odnosu na bazične teme koje su pokrivene temeljnim udžbenicima koji su zadani kao obvezna literatura unutar nekog kolegija. Knjiga koja se ispred vas nalazi trebala bi omogućiti kvalitetniju integraciju znanja te potaknuti studenta na daljnje istraživanje teme u sklopu seminarskih obaveza ili vlastitom unutarnjom motivacijom za stjecanjem znanja. Među predloženim kolegijima na studiju psihologije ovu knjigu preporučujemo kao dodatnu literaturu za sljedeće kolegije: Biološka psihologija, Psihologijska metodologija, Osjeti i percepcija, Kognitivna psihologija, Psihologija pamćenja, Psihologija učenja, Psihologija mišljenja, Psihologija jezika, Ličnost, Psihologija seksualnosti, Socijalna psihologija, Mjerne tehnike u psihofiziologiji, Klinička psihologija, Razvojna psihologija. Izbor tema za ovu knjigu došao je direktno iz psihologijske predavačke struke. Praktički svi suradnici, odnosno autori pojedinih poglavlja, sveučilišni su profesori, nastavnici i predavači za razne psihologijske kolegije i svaki od njih se u svojim predavanjima stalno ili barem povremeno dotiče neuroznanstvenih tema. Dakako, izbor naših tema nije potpun, niti može biti, s obzirom na iznimno velik broj neuropsiholoških tema. Odabrane teme svakako su među istaknutijima ako se kao kriterijem poslužimo iskustvom i odabirom stručnjaka u specifičnim kolegijima.</p>
<p>Zahvaljujemo našim kolegama, autorima poglavlja na odabiru relevantnih tema i vrlo uspješnoj suradnji u svakoj fazi našeg zajedničkog rada. Također zahvaljujemo i našim kolegama recenzentima dr. sc. Draženu Domijanu, dr. sc. Ani Slišković i dr. sc. Ivani Hromatko na vrlo korisnim sugestijama i prijedlozima koji su utkani u sadržaj knjige. Toplo zahvaljujemo Tomislavu Grzunovu, diplomiranom restauratoru – konzervatoru na ilustracijama živčanog sustava i izradi naslovne stranice. Značajnu zahvalu dugujemo i lektorici Editi Medić, prof.</p>
<ul>
<li><p>Studij psihologije (prema kolegijima):</p>
<ul>
<li>Biološka psihologija: cijela knjiga</li>
<li>Osnove kognitivne neuroznanosti: cijela knjiga</li>
<li>Kognitivna psihologija: poglavlja 2, 4, 5, 6, 7, 8</li>
<li>Osjeti i percepcija: poglavlja 2 i 5</li>
<li>Socijalna psihologija: poglavlja 3, 7, 8, 9, 10</li>
<li>Edukacijska psihologija: poglavlja 4, 6, 7, 8</li>
<li>Psihologijska metodologija: poglavlja 2, 4, 5, 7, 8</li>
</ul></li>
<li><p>Studij sociologije: poglavlja 1, 3, 7, 8, 9, 10</p></li>
<li><p>Studij pedagogije: poglavlja 1, 2, 4, 6, 7, 8</p></li>
<li><p>Studij lingvistike: poglavlja 1, 2, 3, 6, 7, 8, 10</p></li>
<li><p>Studij informacijskih znanosti: poglavlja 1, 2, 3, 5, 6, 7</p></li>
<li><p>Studij filozofije: poglavlja 1, 2, 3, 4, 7, 8, 9, 10.</p></li>
</ul>
<p>Konačno, željeli bismo napomenuti da se uredništvo, iako je tražilo od autora da udovolje udžbeničkim zahtjevima, također zauzelo za relativno prohodan stil pisanja. Korištena literatura navedena je u popisu referenci u skladu s APA-inim standardima, dok u samom tekstu nije primijenjen ovaj način citiranja koji je inače uobičajen u znanstvenim člancima. Time je prosječnom čitatelju olakšan kontinuitet čitanja. Također je od autora zatraženo da svoja poglavlja obogate adekvatnim primjerima i anegdotama i time ih učine manje suhoparnim. U komunikaciji s autorima, kao i vlastitim intervencijama u tekst, uredništvo je nastojalo pronaći ravnotežu u poglavljima, i to u gustoći iznesenih spoznaja i detalja, kao i usklađivanju općeg tona knjige. Pritom se ipak pazilo da svako poglavlje zadrži i dio osobnosti i stila pisanja svojeg autora. Na taj način dobili smo ujednačeni niz uzbudljivih priča o mozgu u kojem svaka epizoda o mozgu ima svojeg specifičnog pripovjedača. Nadamo se da smo tekst uspjeli učiniti zanimljivijim i prohodnijim, ne samo studentima psihologije već i širem zainteresiranom čitateljstvu. Vjerujemo da će knjiga ovakvog formata biti interesantna kako studentima drugih društvenih i humanističkih studija tako i širem čitateljstvu koje osjeća uzbuđenje svaki put kad čuje dobru znanstvenu priču. Također se nadamo da smo fleksibilnošću i prohodnošću uspjeli složiti knjigu koja se može čitati i kao popularno-znanstveni tekst. Za nas urednike i autore ove publikacije veliki uspjeh i osobno zadovoljstvo bilo bi ako bi naša knjiga privukla pažnju srednjoškolaca te ih zainteresirala za znanstvenu psihologiju i neuroznanost općenito. Mozak je mnogima od nas, a i nama samima, još uvijek velika nepoznanica. Nevjerojatne i nove spoznaje o načinu njegova funkcioniranja gotovo se svakodnevno otkrivaju. Vrijeme je da uskočimo na neurovlak i da se bolje upoznamo s mozgom i pričama koje ovaj najkompleksniji organ priča o sebi.</p>
<p>Urednici</p>
<p>Nataša Šimić, Pavle Valerjev i Matilda Nikolić Ivanišević</p>
<p>Zadar, veljača 2019.</p>
<h2 id="abstract" class="page_break_before">Abstract</h2>
<h1 id="evolucija-mozga">3. EVOLUCIJA MOZGA</h1>
<p>Irena Pavela Banai</p>
<p>U ovom poglavlju naučit ćemo:</p>
<ul>
<li>o evoluciji živih bića</li>
<li>o evoluciji mozga hominida</li>
<li>o usporedbi mozga čovjeka i drugih vrsta kralježnjaka**</li>
<li>o veličini mozga modernog čovjeka</li>
</ul>
<blockquote>
<p>Ništa u biologiji nema smisla, osim u svjetlu evolucije.</p>
</blockquote>
<p>Theodosius Dobzhansky</p>
<p>Evolucijski biolog Dobzhansky bio je u pravu – biologiju čovjeka i funkcioniranje mozga uistinu ćemo lakše objasniti i razumjeti ako znamo kako su i zašto nastali i evoluirali.</p>
<p>Prije nego što krenemo, provjerite svoje znanje o evoluciji mozga. Što mislite, jesu li dolje navedene tvrdnje točne ili netočne?**</p>
<ul>
<li>Čovjek je nastao od majmuna.</li>
<li>Čovjek ima veći mozak od svih ostalih životinja.</li>
<li>Evolucija se može prikazati kao jedinstvena linija.</li>
<li>Današnji čovjek ima veći mozak nego što su imali neandertalci.</li>
<li>Mozak današnjih ljudi još uvijek raste.</li>
</ul>
<p>Sve su ove tvrdnje netočne, a u ostatku ovog poglavlja možete saznati zašto. Pa krenimo.</p>
<h1 id="kako-funkcionira-evolucija">Kako funkcionira evolucija?</h1>
<p><strong>Evolucija</strong> živih bića proces je tijekom kojeg se događaju postepene promjene. Kada se govori o evolucijskim promjenama, misli se na promjene u genima koji se prenose iz generacije u generaciju. Iako se na evoluciju u većini slučajeva gleda kao na polagani i dugotrajni proces, neke promjene mogu nastati jako brzo. Slučaj ovnova s velikim rogovima u Kanadi dobar je primjer tih brzih promjena i načina na koji evolucija funkcionira. Naime, u jednom području u Kanadi veliki uvijeni rogovi ovnova predstavljaju prestižan trofej lokalnim lovcima. Legalni lov takvih ovnova doveo je do smanjenja veličine rogova za čak 25 % u posljednjih 30 godina. Što se dogodilo? S obzirom na to da su lovci ubijali samo one ovnove koji su imali velike rogove, geni tih ovnova nisu preneseni na sljedeće generacije potomaka. Gene su prenosili samo ovnovi s manjim rogovima, zbog čega je u populaciji ovnova prosječna veličina rogova znatno smanjena. Dakle, pod utjecajem čovjeka došlo je do promjene učestalosti pojedinih gena. To je primjer tzv. <strong>umjetnog odabira</strong> koji se dogodio u jako kratkom periodu. Ljudi su „odabrali" koji će se geni prenositi na sljedeće generacije. Mnogo je drugih sličnih slučajeva, kao što su primjerice farmeri koji pospješuju razmnožavanje samo onih krava koje daju više mlijeka ili poljoprivrednici koji su selektivno uzgojili povrće kakvo danas jedemo. Poznat je i primjer selektivnog uzgoja buldoga, koji je doveo do velike promjene njegove anatomije zbog koje danas ima problema s disanjem. Na isti način, selektivnim razmnožavanjem, nastale su sve evolucijske promjene tijekom više milijuna godina, ali u tom slučaju odabir nije vršio čovjek, nego priroda. Jedna je od tih promjena uspravno hodanje. Zamislite period od prije 4,4 milijuna godina u evolucijskoj povijesti. To je period neposredno prije pojave uspravnog hoda. Naši tadašnji predci koji su bili nešto uspravniji, imali su prednost naspram onih koji su hodali četveronoške. Uspravniji hod omogućio im je bolje uočavanje opasnosti i hrane u visokim savanama, dosezanje hrane koja je bila visoko, slobodne ruke za manipulaciju alatima i slično. Tako su imali veće šanse preživjeti i prenijeti svoje „uspravne" gene na sljedeće generacije. Postupno, „četveronožni" geni izgubili su se iz populacije. Taj proces prenošenja gena povezanih s većim preživljavanjem (ili još preciznije govoreći, s većom vjerojatnošću reprodukcije) na iduće generacije nazivamo <strong>prirodnim odabirom</strong>. Dakle, prirodnim se odabirom geni u populaciji polako mijenjaju nakupljanjem postupnih promjena iz generacije u generaciju. Istim se postupnim promjenama razvila naša vrsta, a <strong>vrstu</strong> možemo definirati kao skup genetski sličnih jedinki koje se mogu međusobno razmnožavati.</p>
<p>Proučavanjem fosilnih ostataka, usporedbom živih vrsta te genetičkim analizama ljudi i drugih vrsta istraživači su otkrili kako je tekla evolucija čovjeka. Evoluciju se može prikazati kao razgranato stablo (iako će neki reći da više nalikuje na grm zbog gustoće grančica) na kojem najmanja grančica predstavlja jednu vrstu. Zajednička grana na kojoj je više manjih grančica predstavlja zajedničkog pretka. Dakle, sve su vrste međusobno povezane, iako mogu biti vremenski udaljene milijunima godina. Pojednostavljeno na Slici 3.1., vrste A, B i C imaju zajedničkog pretka P. Možemo tako zamisliti da A predstavlja današnjeg čovjeka, a B čimpanzu. Dakle, ljudi nisu potekli od majmuna i čimpanzi, nego imaju zajedničkog pretka, zbog čega dijele gotovo 99 % DNA.</p>
<p>(SLIKA 3.1. OVDJE)</p>
<p><strong>U evolucijskom su se stablu, unutar skupine kralježnjaka, pojavili prvi sisavci otprilike prije 180 milijuna godina. Sisavci se dalje dijele na redove, kao što je red primata. Primati su pak podijeljeni u porodice, od kojih jednu čine hominidi, a oni su podijeljeni u dva roda: <em>Australopitecus</em> i <em>Homo</em>. Čovjek, <em>Homo</em> <em>sapiens</em>, spada u rod <em>Homo</em>, a smatra se da se razvio iz jedne vrste <em>Australopitecusa</em> (Slika 3.2.).</strong></p>
<p>(SLIKA 3.2. OTPRILIKE OVDJE)</p>
<h1 id="evolucija-mozga-hominida">Evolucija mozga hominida</h1>
<p>Općenito se istraživanje evolucijskog razvoja čovjeka temelji na brojnim fosilnim ostatcima i proučavanju živućih životinjskih vrsta. Međutim, kada je riječ o istraživanju evolucije mozga, postoji jedan problem. Mozak se ne fosilizira, tako da se o njegovu evolucijskom razvoju može zaključivati samo indirektno, na temelju veličina pronađenih lubanja. Veličine tih lubanja potom se rekonstruiraju izradom kalupa od gipsa, s pomoću kojih se procjenjuje volumen lubanje te stoga i volumen mozga. Ta je metoda omogućila prikupljanje informacija o razvoju mozga od pojave <em>Australopitecusa afarensisa</em>, otprilike prije 3 do 4 milijuna godina, pa sve do danas. Najpoznatiji je <em>Australopitecus aferensis</em> <strong>Lucy</strong>, čije su kosti otkrivene 1974. godine u Etiopiji. Dobila je ime prema pjesmi Beatlesa <em>Lucy in the sky with diamonds</em>, koja je glasno svirala u kampu gdje je bio smješten tim istraživača koji su iskopali kosti. Istraživanja njezinih kostiju dovela su do bitnih spoznaja o toj vrsti, a jedna od njih je da su ti naši predci hodali uspravno i da su bili niskog rasta (nešto viši od jednog metra). Pronalazak Lucy je, osim u istraživačkim krugovima, odjeknuo i u javnosti. Važnost njezina pronalaska opisana je u knjizi <em>Lucy:</em> <em>The Beginning of Humankind</em>, autora Donalda Johansona, koji ju je i pronašao. Njezine se kosti danas čuvaju u posebnim uvjetima u Nacionalnom muzeju u Addis Ababi u Etiopiji.</p>
<p>Na Slici 3.3. prikazan je pretpostavljeni slijed pojave različitih hominida tijekom evolucijske povijesti, počevši od <em>Australopitecusa afarensisa</em>. Iako su se pojavljivale različitim redoslijedom, ne znači da su sve vrste živjele u odvojenim vremenskim razmacima. Primjerice, <em>Homo habilis</em> i <em>Homo erectus</em> živjeli su u isto vrijeme dug period. Također, već je i spomenuto kako su <em>Homo sapiens</em> i <em>Homo neandertalensis</em> bili suvremenici.</p>
<p>Istraživač David Geary sa Sveučilišta u Missouriju sažeo je prikupljene informacije o povećanju mozga prikazanih vrsta hominida. Uočio je da se mozak malo povećavao svaki put kad bi se pojavila nova vrsta, s tim da je prvo veće povećanje volumena mozga utvrđeno kod pojave roda <em>Homo</em> (<em>Homo habilis</em>), otprilike prije 2,5 milijuna godina. Primjerice, <em>Australopitecus africanus</em> je imao volumen mozga od oko 500 cm<sup>3</sup>, dok je prosječni volumen mozga <em>Homo habilisa</em> bio oko 650 cm<sup>3</sup>. Osim što je rod <em>Homo</em> u usporedbi s rodom <em>Australopitecus</em> imao veći mozak, smatra se da je imao i više vijuga i brazdi, što znači da je površina moždane kore bila veća. Mozak se dalje značajno povećao kada se pojavila vrsta <em>Homo erectus</em>, s prosječnim volumenom mozga od oko 900 cm<sup>3</sup>. <em>Homo erectus</em> je izrazito važna vrsta za proučavanje evolucije čovjeka jer je to prva vrsta hominida čiji su ostatci pronađeni izvan Afrike (u Kini i Indoneziji). Također se smatra da je to prva vrsta hominida koja je kontrolirala vatru.</p>
<p>(SLIKA 3.3. OVDJE)</p>
<p>Daljnje povećanje mozga, čak do 1500 cm<sup>3</sup>, uočeno je kod našeg bliskog srodnika, <em>Homo neandertalensisa</em>, poznatog kao neandertalac. Neandertalac je imao nešto veći mozak od mozga <em>Homo sapiensa</em>. Zvuči nevjerojatno, ali nije pogrešno – neandertalac je uistinu imao veći mozak od nas! Kako je to moguće? Ti su hominidi bili teži i imali su više mišićnog tkiva od čovjeka. Osim toga, živjeli su za vrijeme ledenih doba, a vrste koje žive u hladnijim uvjetima, imaju i veći mozak. Zapravo, neandertalci su uspjeli preživjeti u nekim od najgorih uvjeta poznatih čovjeku. Uspjeli su jer su živjeli u spiljama, kontrolirali vatru i odijevali životinjsku kožu.</p>
<p>Fosilni ostatci ukazuju da su neandertalci i današnji čovjek, <em>Homo sapiens,</em> evoluirali od istog pretka te su više tisuća godina bili suvremenici. Genetski nalazi čak pokazuju da su se međusobno razmnožavali. Pronađeno je da moderni ljudi s područja Europe dijele 1 – 4 % DNA s neandertalcima. Istraživači s Max Planck Instituta za evolucijsku antropologiju otkrili su da je moderni čovjek od neandertalaca „naslijedio" gene koji su odgovorni za imunološki sustav. To je vjerojatno pomoglo <em>Homo sapiensu</em> da se uspješno obrani od različitih vrsta patogena kada je počeo naseljavati područje Europe. Neki teoretičari evolucije smatraju da su te dvije vrste hominida bile u interakciji desetak tisuća godina tijekom ledenog doba, sve dok se broj neandertalaca nije značajno smanjio prije otprilike 40 000 godina. Tada nestaju svi njegovi tragovi. Ostatci neandertalaca pronađeni su i u Hrvatskoj, na <strong>Hušnjakovom brdu</strong> u Krapini. Iskapanja ostataka trajala su čak šest godina, od 1899. do 1905. Pronađene su kosti više hominida u životnoj dobi od 2 do 40 godina. To je nalazište dalo veliki doprinos europskoj i svjetskoj znanosti o evoluciji čovjeka. Više informacija o hrvatskim neandertalcima možete naći u Muzeju krapinskih neandertalaca u Krapini.</p>
<p><em>Homo sapiens</em> je nastavio naseljavati područje Europe i nakon izumiranja neandertalaca te se ubrzo razvija u anatomski modernog čovjeka, koji danas ima prosječni volumen mozga oko 1400 cm<sup>3</sup>. Iako je taj volumen manji od volumena mozga neandertalaca, on je gotovo tri puta veći od volumena mozga današnjih čimpanzi (prosjek oko 400 cm<sup>3</sup>) i gorila (prosjek oko 500 cm<sup>3</sup>). Dakle, osim proučavanja fosilnih ostataka, ovakve usporedbe veličine mozga čovjeka i drugih živućih životinjskih vrsta također su bitne u proučavanju evolucije mozga. Sličnost s nekim drugim vrstama ukazuje da imamo zajedničkog pretka i da je grana te vrste u evolucijskom stablu blizu naše grane. Takve usporedbe omogućuju istraživačima da upotpune evolucijsko stablo i otkriju podrijetlo današnjeg čovjeka i složenog živčanog sustava. Što smo ovom metodom saznali do sada?</p>
<h1 id="usporedbe-mozga-čovjeka-i-drugih-vrsta-kralježnjaka">Usporedbe mozga čovjeka i drugih vrsta kralježnjaka</h1>
<p>Bilo bi logično da se evolucijskim razvojem mozak kralježnjaka (Slika 3.4.) sve više i više povećavao. Tako bi ribe koje su se pojavile ranije, trebale imati manji mozak od gmazova koji se pojavljuju nakon njih. Slično, gmazovi bi trebali imati manji mozak od sisavaca jer su se sisavci pojavili kasnije. Istom bismo logikom očekivali da sisavci imaju nešto manji ili jednak mozak kao i današnje ptice jer su se obje vrste pojavile približno u isto vrijeme. Međutim, ptice imaju daleko manji mozak od sisavaca kao što je čovjek. Iz toga proizlazi da evolucijski razvoj nije linearan, odnosno ne može se opisati jednostavnom linijom. Inače, današnje su ptice jedini „živući dinosauri". One su se razvile od teropoda – vrste dinosaura s kojima dijele brojne zajedničke karakteristike. Najpoznatiji i najstariji blizak srodnik pretku današnjih ptica je <strong>Archaeopteryx</strong>. Najcjelovitiji fosilni primjerak <em>Archaeopteryxa</em> nalazi se u Prirodoslovnom muzeju u Berlinu. Pronašao ga je 1874. godine njemački farmer Jakob Niemeyer koji ga je, možda i ne znajući njegovu znanstvenu vrijednost, prodao kako bi mogao kupiti kravu za svoju farmu. Nakon nekoliko različitih vlasnika, taj je dragocjeni fosil dospio do muzeja.</p>
<p>(SLIKA 3.4. OTPRILIKE OVDJE)</p>
<p>Kako naglašava neuroznanstvenik Stephen Marc Breedlove i njegovi suradnici sa sveučilišta u Michiganu, razvoj mozga različitih životinjskih vrsta nije imao linearan slijed jer je evolucija kralježnjaka tekla odvojeno i simultano tijekom više od 200 milijuna godina, baš poput razgranatog evolucijskog stabla. Za demonstraciju odvojenog i simultanog razvoja Breedlove i suradnici daju primjer mozga morskog psa, koji spada u grupu riba. Današnji morski pas ima veći mozak od primitivnih morskih pasa iz evolucijske povijesti. Međutim, povećanje mozga današnjeg morskog psa nije povezano s povećanjem mozga današnjeg čovjeka koji spada u grupu sisavaca – razvoj morskog psa i čovjeka zapravo su dvije odvojene grane na evolucijskom stablu. Dakle, njihove su evolucijske promjene neovisne iako imaju davnog zajedničkog pretka iz kojeg su se razvili svi kralježnjaci.</p>
<p>Da su svi kralježnjaci međusobno povezani preko spomenutog zajedničkog pretka, govore nalazi da svi mozgovi kralježnjaka imaju istu građu neurona. No mozgovi različitih kralježnjaka razlikuju se po ukupnoj veličini, razgranatosti izdanaka neurona i broju međusobnih veza među neuronima. Isto tako, svi mozgovi kralježnjaka sadrže iste dijelove, ali se također razlikuju u veličini. Primjerice, svaki dio mozga čovjeka ima „svog dvojnika" u mozgu miša. Pod dvojnikom se misli na osnovu strukture, koja uključuje koru velikog mozga, moždano deblo, srednji mozak, međumozak i slično. Može se reći da su razlike u mozgu različitih vrsta sisavaca kvantitativne prirode, odnosno razlikuju se u veličini, a ne u osnovnoj strukturi. Tako moždana kora kod čovjeka zauzima veći dio cijelog mozga nego kora mozga kod miševa. Dok je moždana kora čovjeka naborana, kod miša je glatka.</p>
<p>Dakle, istraživanja evolucije mozga bila su usmjerena na veličinu mozga. Logično je bilo očekivati da veći mozak označava i veće kognitivne sposobnosti te da bi čovjek trebao biti na vrhu evolucijske ljestvice. Iznenađenje je uslijedilo kada je otkriveno da slonovi, dupini i plavi kitovi imaju veći mozak od nas, dok je mozak morževa sličan našem. Da podsjetimo, i neandertalci su imali veći mozak od nas, kao i izumrli mamuti. Možemo za primjer uzeti i mozak plavog kita koji je izrazito veći od mozga crvenogrlog kolibrića. Unatoč toj razlici, obje vrste pokazuju iznimno složen sklop ponašanja: imaju složeno glasanje, brane svoj teritorij, zavode partnere, odgajaju svoje potomke i migriraju u daleke krajeve. Iz toga slijedi da veličina mozga ne govori mnogo o kognitivnim sposobnostima vrste.</p>
<p>Kada su istraživači shvatili da apsolutna veličina mozga ipak nije dobra mjera sposobnosti i inteligencije vrste, uveli su novu mjeru – stavili su u omjer težinu mozga i težinu tijela. Što je mozak teži u odnosu na tijelo, omjer je veći, i obrnuto. Pa izračunajmo koliko taj omjer iznosi kod čovjeka. Težina mozga je 1,4 kg, a tijela u prosjeku 75 kg. 1,4/75 = 1,86 %. Omjer kod čimpanzi iznosi 0,88 % (0,4 kg/45 kg), što ukazuje da ljudi imaju razvijenije sposobnosti od svojeg bliskog srodnika. Iako se ta formula čini logičnom, ona također pokazuje da omjer kod male rovke iznosi čak 10 % (3 g/30 g = 10 %)! To je inače najveći omjer nađen kod životinja i zapravo nam govori da bi rovke trebale biti pet puta inteligentnije od nas. Dakle, formula očito nije dovoljno dobra. Istraživači su se potom zapitali kakav je općeniti odnos između težine tijela i težine mozga različitih vrsta. Kao odgovor na to pitanje, razvili su tzv. <strong>kvocijent encefalizacije</strong>. Navedeni je kvocijent mjera <em>relativne težine</em>, umjesto apsolutne težine mozga. Dobiva se kao omjer stvarne težine mozga i predviđene težine mozga kakvu bismo očekivali za vrstu određene težine tijela. Pojednostavljeno, recimo da znamo da riba koja teži 100 grama ima mozak prosječne težine od 0,1 gram. Ako pretpostavimo da ribe i sisavci imaju jednaku inteligenciju i sposobnosti, tada bismo očekivali da i sisavac koji teži 100 grama ima mozak od 0,1 gram. Međutim, istraživači su uočili da sisavac koji teži 100 grama (npr. miš) ima u prosjeku mozak težine oko 1 gram, što je 10 puta teže od mozga ribe u našem primjeru. Dakle, u ovom primjeru sisavci imaju veći kvocijent encefalizacije od riba. Jednako kao što možemo uspoređivati kvocijente encefalizacije različitih razreda životinja (ribe <em>vs</em>. sisavci), možemo uspoređivati kvocijente različitih vrsta unutar istog razreda (npr. čovjek <em>vs</em>. miš unutar razreda sisavaca). Takve su usporedbe dovele do saznanja da čovjek ima najveći kvocijent encefalizacije u usporedbi sa svim drugim vrstama. U tablici 3.1. možete vidjeti koliko iznose kvocijenti za različite vrste prema istraživaču Cairòu.</p>
<p><em>Tablica 3.1. Kvocijent encefalizacije za različite vrste</em></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Vrsta</strong></th>
<th style="text-align: left;"><strong>Kvocijent encefalizacije</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Čovjek</td>
<td style="text-align: left;">6,56</td>
</tr>
<tr class="even">
<td style="text-align: left;">Velika pliskavica</td>
<td style="text-align: left;">5,55</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Makaki majmun</td>
<td style="text-align: left;">3,15</td>
</tr>
<tr class="even">
<td style="text-align: left;">Pavijan</td>
<td style="text-align: left;">2,81</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Čimpanza</td>
<td style="text-align: left;">2,63</td>
</tr>
<tr class="even">
<td style="text-align: left;">Gorila</td>
<td style="text-align: left;">1,75</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Lav</td>
<td style="text-align: left;">0,73</td>
</tr>
<tr class="even">
<td style="text-align: left;">Tigar</td>
<td style="text-align: left;">0,68</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Plavi kit</td>
<td style="text-align: left;">0,38</td>
</tr>
</tbody>
</table>
<p>Dakle, na temelju toga možemo reći da ljudi imaju najveći mozak u relativnom smislu. Razlika u veličini mozga čovjeka i ostalih životinja uglavnom proizlazi iz većeg prednjeg dijela frontalnog režnja te većih asocijativnih područja koja sadrže veći broj neurona nego kod ostalih primata. Razvoj moždane kore, odnosno njezina prednjeg dijela frontalnog režnja, čovjeku je omogućio visoke kognitivne sposobnosti, apstraktno mišljenje, složenu jezičnu komunikaciju, stvaranje širokih društvenih mreža, industrijsku i računalnu revoluciju, let u svemir i slično. Povećanje određenih dijelova prednje moždane kore, kao i veza između pojedinih područja, dovelo je do razvoja sposobnosti koje nas čine ljudima. Antropolog i evolucijski psiholog Robin Dunbar sa Sveučilišta u Oxfordu smatra da je do povećanja moždane kore došlo da bi se ljudi uspješno snašli u velikoj društvenoj mreži i održavali odnose u zajednicama. Navedeno je poznato kao <strong>hipoteza društvenog mozga</strong>. Dunbar je utvrdio da postoji povezanost između veličine zajednice, učestalosti međusobnog druženja i veličine prednjeg dijela moždane kore. Što su zajednice veće, potrebno je procesirati više informacija, zbog čega je potreban i veći dio moždane kore. Vezano za uspješno preživljavanje u takvim složenim društvenim zajednicama, našim je predcima od iznimne važnosti bilo razumjeti namjere drugih članova zajednice te njihovu spremnost na suradnju. Smatra se da je suradnja članova zajednice tijekom lova, obrane od predatora, traženja hrane i slično, univerzalna karakteristika koja je nastala pojavom roda <em>Homo</em>. Kako bi suradnja bila uspješna, naši su predci morali biti sposobni detektirati varalice, odnosno članove zajednice koji nisu spremni za suradnju. Uistinu, čini se da je tijekom evolucijske povijesti nastao modul u mozgu upravo za prepoznavanje varalica i laži. Bitno je napomenuti da se, kada se govori o modulu, ne misli na specifičan dio mozga koji je moguće prepoznati tehnikama oslikavanja mozga, već o složenom sustavu i mreži neurona u živčanom sustavu. Navedeni je modul samo jedan od brojnih evolucijskih adaptacija mozga koje rješavaju specifične probleme iz prošlosti ljudskih predaka. Pretpostavlja se da postoje i druge slične adaptacije kao što su mogućnost prepoznavanja lica, detektiranje emocionalnih ekspresija, pa čak i doživljavanje ljubomore. Smatra se da je ljubomora kao složena emocija evoluirala s ciljem detektiranja i uklanjanja prijetnje trenutnoj ljubavnoj vezi, što je povećavalo vjerojatnost uspješnog razmnožavanja i prenošenja gena na sljedeće generacije. Zanimljivo, brojna istraživanja pokazuju da muškarci i žene različito reagiraju na različite oblike prijetnje vezi. Nalazi ukazuju da je muškarac ljubomorniji na seksualnu nevjeru partnerice. Smatra se da je to zbog toga što je time ugrožena njegova sigurnost u očinstvo te je veća vjerojatnost ulaganja u potomstvo koje nije njegovo. S druge strane, žena je uvijek sigurna da je dijete njezino, ali riskira partnerovo napuštanje i gubitak njegove potpore. Vjerojatnost napuštanja je veća ako se muškarac zaljubi u drugu ženu te se pretpostavlja da su žene tijekom evolucije razvile posebnu osjetljivost na znakove emocionalne nevjere. Svi ovi i slični moduli u živčanom sustavu razvijali su se tijekom evolucijske povijesti jer su povećavali vjerojatnost uspješnog preživljavanja i razmnožavanja. Iako čovjek ima relativno najveći mozak, nisu svi dijelovi njegova mozga veći od dijelova mozga drugih životinja. Neki dijelovi mozga su kod čovjeka manji. Primjerice, njušna lukovica, struktura smještena u prednjem mozgu koja je važna za osjet njuha, značajno je veća kod pasa i koza. Slično, područja mozga zadužena za lokalizaciju i prepoznavanje zvukova velika su kod šišmiša i dupina. Također je bitno spomenuti da to što čovjek ima relativno najveći mozak ne znači ujedno da je najprilagođeniji i najsposobniji od svih ostalih vrsta na planetu. Sve su druge životinje, kao i čovjek, dobro prilagođene okolini u kojoj žive. Upravo je ta okolina dovela do mozga kakvog danas poznajemo kod čovjeka i svih ostalih životinjskih vrsta. Primjerice, okolina se može razlikovati po dostupnosti hrane za životinje. Zanimljivo je da životinje koje žive u okolini u kojoj hrana nije lako dostupna, imaju veće mozgove. Zašto je to tako? Većina vrsta veliku količinu energije i vremena troši na pronalaženje hrane i koristi različite strategije kako bi došla do nje. Što je hranu teže naći u okolini, strategije moraju biti složenije. Zbog toga vrste koje teže pronalaze hranu imaju i veće mozgove koji im omogućuju složene strategije.</p>
<p>Prednosti većeg mozga su jasne – veći mozak omogućava širok raspon različitih sposobnosti. Međutim, neuroznanstvenik Breedlove naglašava da veliki mozak ima nekih svojih nedostataka. Da bi se razvio veći mozak, potreban je duži period trudnoće, što može predstavljati problem za majku. Nadalje, veliki mozak zahtijeva i veću lubanju, što može komplicirati porod. Komplikacije mogu nastati ako je lubanja prevelika da prođe kroz uski porođajni kanal, posebice ako majka ima usku zdjelicu. U tom slučaju i dijete i majka mogu biti u životnoj opasnosti. Ipak, današnji napredak medicine u području ginekologije i opstetricije uvelike smanjuje vjerojatnost negativnih ishoda tijekom poroda. Primjerice, danas se veliki broj poroda obavlja carskim rezom, zbog čega i žene s jako uskom zdjelicom mogu bez većih poteškoća roditi zdravo dijete. Istraživači Mitteroecker i suradnici sa Sveučilišta u Beču smatraju da je sve veći broj poroda carskim rezom mogao dovesti do promjena u ljudskoj evoluciji. Autori objašnjavaju da su tijekom evolucijske prošlosti žene s uskom zdjelicom imale manju šansu preživljavanja tijekom poroda. U isto vrijeme, prirodni je odabir djelovao tako da se rađaju djeca s većom lubanjom jer su velika novorođenčad ujedno imala i veću šansu preživljavanja. Dakle, riječ je o svojevrsnom konfliktu – velika lubanja djeteta mogla je dovesti u opasnost život rodilje, ali u isto je vrijeme mogla dovesti i do veće kasnije adaptibilnosti djeteta, što je u literaturi poznato kao <strong>opstetricijska dilema</strong><em>.</em> Navedeno znači da je morao postojati „kompromis" između veličine zdjelice majke i veličine djeteta da bi oboje uspješno preživjeli. Moguće je da je carski rez „poremetio" taj kompromis jer danas i žene s uskom zdjelicom uspješno rađaju veliku novorođenčad, prenoseći gene na svoje kćeri koje će vjerojatno također imati usku zdjelicu. Moguće je da se zbog toga sve više rađaju i djeca s većom lubanjom, jer velika lubanja više nije prijetnja uspješnom porodu. Ta je mogućnost uistinu zanimljiva, a buduća će istraživanja svakako dati uvid u stvarne podatke te otkriti koliko su uistinu veliki efekti carskog reza na evoluciju čovjeka.</p>
<p>Postoje i drugi problemi koji se tiču evolucijskog razvoja mozga. Prvo, da bi mozak dosegao veličinu kao kod odraslog čovjeka, mora se razvijati i nakon rođenja, što znači da je dijete duže ovisno o majci. Nadalje, naš mozak troši jako mnogo energije. U prvom poglavlju susreli ste se s podatkom da taj organ troši 20 % naše energije iako zauzima samo 2 % naše mase. Uzevši u obzir veliku količinu energije koju mozak troši za svoj rad, možda ste među onima koji su se zapitali je li moguće napornom mentalnom aktivnošću (npr. učenjem za ispit) potrošiti više energije te time i više kalorija. Konačno, može li se tako smršavjeti? Ako ste se to zapitali, niste jedini, ali odgovor je nažalost negativan – rješavanje statističkih zadataka neće ukloniti efekte čipsa koji ste pojeli. Profesor David Levitsky s Cornell University objasnio je da povećanje mentalne aktivnosti uistinu povećava potrošnju energije i gubljenje kalorija – ali samo do 10 kalorija dnevno. To znači da bi bilo potrebno nekoliko godina da se promijeni broj na vagi. A zamislite samo kako bi bilo zabavno da možemo smršavjeti ležeći na kauču i rješavajući složene matematičke jednadžbe.</p>
<p>Sada kada znamo kako se mozak razvio tijekom evolucijske povijesti, pitanje je što se događa s mozgom posljednjih desetak tisuća godina. Je li se još povećao ili je ostao isti? Mijenja li se još uvijek ili je razvoj stao pojavom modernog čovjeka?</p>
<h1 id="mozak-modernog-čovjeka">Mozak modernog čovjeka</h1>
<p>Istraživanja koja je proveo profesor John Hawks sa Sveučilišta u Winsconsinu pokazuju da se u posljednjih 20 000 godina mozak modernog čovjeka – smanjuje! Hawks daje zapanjujuće podatke o brzini smanjivanja mozga: ako se smanjivanje nastavi jednakim tempom, u sljedećih 20 000 godina naš će mozak biti veličine mozga <em>Homo erectusa</em>. Naravno, taj je podatak samo ilustracija brzine smanjivanja, zapravo je malo vjerojatno da će se to uistinu i dogoditi. Neovisno o tome, činjenica jest da je došlo do malog smanjenja veličine mozga i postavlja se pitanje zašto. Nekoliko je mogućih razloga. Prvo, prosječna veličina tijela modernih ljudi smanjila se tijekom posljednjih 10 000 godina. Kako je ranije spomenuto, veća masa tijela uglavnom je povezana s većim mozgom. Nadalje, u posljednjih 20 000 godina otkako se mozak smanjuje, nastupilo je razdoblje holocena koje je obilježeno višim temperaturama i toplijim klimatskim uvjetima. Toplija je klima pak povezana s manjim mozgom. Christopher Stringer, paleoantropolog iz Prirodoslovnog muzeja u Londonu predlaže mogućnost da je način života modernog čovjeka doveo do smanjenja mozga. Na primjer, pripitomljene životinje imaju manje mozgove od svojih srodnika koji žive u divljini, vjerojatno jer ne trebaju promišljati o strategijama pronalaska hrane i izbjegavanju neprijatelja. Ne treba dodatno pojašnjavati da je moderni čovjek danas poprilično „pripitomljen" i zaštićen u svojem domu za razliku od prvih <em>Homo sapiensa</em>, što je možda dovelo do smanjenja njegova mozga.</p>
<p>Kognitivni znanstvenik i evolucijski psiholog David Geary objašnjava svoju teoriju zašto se mozak smanjuje. Za to ćemo pojašnjenje kratko ponoviti kako evolucija funkcionira. Dakle, ako se neki pojedinci iz nekog razloga više razmnožavaju, logično je da imaju i više potomaka koji nasljeđuju njihove gene. Posljedično, tijekom mnogo generacija frekvencija gena tih pojedinaca u populaciji će se povećati. Naši predci koji su imali veći mozak, bili su uspješniji u preživljavanju i razmnožavanju te je stoga došlo do povećanja mozga. Međutim, Geary smatra da to više nije slučaj jer je posljednjih desetak tisuća godina čovjek počeo stvarati velike društvene zajednice, živjeti u udobnosti svojeg doma u gušće naseljenim područjima te je uveo podjelu rada i učinkovitiji pronalazak i uzgoj hrane. Od tada se uspješno mogu razmnožavati i ljudi s manjim mozgom i nižih sposobnosti. Na tu je ideju Geary došao kada je istraživanjem utvrdio da ljudi u gušće naseljenim područjima imaju manju lubanju i vjerojatno manji mozak. To ga je navelo na zaključak da razvojem složenih društvenih zajednica ljudi ne moraju imati velike adaptivne sposobnosti da bi preživjeli jer im pomažu drugi članovi zajednice. Takav je stil života poprilično različit od života naših predaka čiji je život ovisio o uspješnim strategijama pronalaska hrane, lovu i izbjegavanju predatora. David Geary također na duhovit način svoju teoriju o smanjenju mozga povezuje s filmom <em>Idiocracy</em> iz 2006. godine, redatelja Mikea Judgea. U filmu se Joe Bauers, kojeg glumi Luke Wilson, budi iz hibernacije nakon 500 godina i shvaća da je najpametnija osoba u Americi jer se cijela populacija pretvorila u neinteligentne ljude. Dakako, to se nije zapravo dogodilo s modernim čovjekom, ali je zabavan znanstveno-fantastični prikaz koji vrijedi pogledati. Čini se da još uvijek nemamo odgovor na pitanje zašto se mozak smanjio i kakav će biti u budućnosti, no ta problematika svakako predstavlja izazov za daljnja istraživanja. Osim toga, zasigurno nas čekaju nova otkrića koja će upotpuniti sliku našeg evolucijskog stabla i dovesti do novih spoznaja o evoluciji ovog najkompleksnijeg organa modernog čovjeka. Ova su istraživanja iznimno važna jer su milijuni godina evolucije doveli do mozga kakvog imamo danas i oblikovali naše cjelokupno ponašanje.</p>
<p><strong><br />
</strong></p>
<p><strong>Zaključci</strong></p>
<p>1. Evolucija živih bića proces je tijekom kojeg se događaju postupne promjene u genima koje se prenose iz generacije u generaciju. Prirodni odabir označava proces prenošenja gena povezanih s većim preživljavanjem na iduće generacije. Pod umjetnim odabirom podrazumijevaju se promjene učestalosti gena u populaciji, koje se događaju pod utjecajem čovjeka. Vrstu možemo definirati kao skup genetski sličnih jedinki koje se mogu međusobno razmnožavati.</p>
<p>2. Evolucija se može prikazati kao razgranato stablo na kojem najmanja grančica predstavlja jednu vrstu, dok zajednička grana na kojoj se nalazi više manjih grančica predstavlja zajedničkog pretka. Unutar skupine kralježnjaka prvi su se sisavci pojavili otprilike prije 180 milijuna godina. Sisavci se dijele na redove, kao što je primjerice red primata. Oni se dalje dijele u porodice, od kojih jednu čine hominidi koji se dalje dijele u dva roda: <em>Australopitecus</em> i <em>Homo.</em> Čovjek, <em>Homo sapiens</em>, spada u rod <em>Homo</em>, a najvjerojatnije se razvio iz jedne vrste <em>Australopitecusa.</em></p>
<p>3. Istraživanja evolucijskog razvoja čovjeka temelje se na proučavanjima fosilnih ostataka i živućih životinjskih vrsta. O evolucijskom razvoju mozga zaključuje se indirektno na temelju veličina pronađenih lubanja. Lucy je najpoznatiji <em>Australopitecus aferensis</em> čije su kosti otkrivene u Etiopiji 70-ih godina prošlog stoljeća. S pojavom novih vrsta njihov mozak se povećavao, s tim da je prvo značajnije povećanje volumena mozga utvrđeno kod pojave roda <em>Homo</em> otprilike prije 2,5 milijuna godina. Mozgovi modernog čovjeka imaju prosječan volumen oko 1400 cm<sup>3</sup>.</p>
<p>4. Mozgovi različitih kralježnjaka razlikuju se u ukupnoj veličini, razgranatosti izdanaka i broju sinaptičkih veza među neuronima. Kvocijent encefalizacije predstavlja mjeru relativne težine mozga, a dobije se kao omjer stvarne težine mozga i predviđene težine mozga kakvu bismo očekivali za vrstu određene težine tijela. Usporedbe kvocijenata encefalizacije različitih vrsta rezultirale su spoznajom da čovjek u usporedbi sa svim drugim vrstama ima najveći mozak u relativnom smislu. U usporedbi s drugim primatima, čovjek ima veće prednje dijelove frontalnog režnja, a njegova asocijativna kortikalna područja sadrže veći broj neurona. Navedeno mu je omogućilo visoke kognitivne sposobnosti, apstraktno mišljenje i jezičnu komunikaciju. Hipoteza društvenog mozga pretpostavlja povećanje moždane kore kako bi se ljudi uspješno snašli u većoj društvenoj mreži i kako bi održavali odnose u zajednicama. Iako veći mozak omogućava širok raspon različitih sposobnosti, za njegov razvoj potreban je duži period trudnoće te veća lubanja. Opstetricijska dilema pretpostavlja kompromis između veličine zdjelice majke i veličine djeteta kako bi oboje uspješno preživjeli porod.</p>
<p>5. Posljednjih se 20 000 godina mozak modernog čovjeka smanjuje. Nekoliko je mogućih razloga: topliji klimatski uvjeti, smanjenje tjelesne mase, način života modernog čovjeka, život u gušće naseljenim područjima.</p>
<p><strong>Testirajte se</strong></p>
<ol type="1">
<li><p>Navedite i opišite neke primjene umjetnog odabira.</p></li>
<li><p>Koje su sve moguće prednosti uspravnog u usporedbi s četveronožnim hodanjem za ljude?</p></li>
<li><p>Koji su mogući razlozi zbog kojih je neandertalac imao veći mozak od današnjeg čovjeka?</p></li>
<li><p>Razmislite koji su sve mogući nedostatci i posljedice evolucijskog povećanja mozga.</p></li>
<li><p>Navedite hipotetske uzroke koji su mogli utjecati na smanjenje mozga suvremenog čovjeka.</p></li>
</ol>
<p><strong>Preporučena dodatna literatura</strong></p>
<p>Miller, G. (2007). <em>Razum i razmnožavanje: Kako je izbor seksualnih partnera oblikovao ljudsku narav.</em> Zagreb, Hrvatska: Algoritam.</p>
<p>Miller, J. i Van Loon, B. (2010). <em>Introducing Darwin: A Graphic Guide</em>. United Kingdom: Icon Books Ltd.</p>
<p>Ridley, M. (2004). <em>Evolucija: klasici i suvremene spoznaje</em>. Zagreb: Naklada Jasenski i Turk.</p>
<p><strong>Važni pojmovi</strong></p>
<p><strong>Archaeopteryx</strong> Najstariji i najpoznatiji blizak srodnik pretku današnjih ptica.</p>
<p><strong>Evolucija Proces tijekom kojeg se događaju postepene promjene u genima koji se prenose iz generacije u generaciju.</strong></p>
<p><strong>Hipoteza društvenog mozga</strong> Pretpostavka da je do povećanja moždane kore došlo kako bi se ljudi uspješno snašli u velikoj društvenoj mreži i održavali odnose u zajednicama.</p>
<p><strong>Hušnjakovo brdo</strong> Hrvatsko pronalazište ostataka neandertalaca koje je dalo veliki doprinos europskoj i svjetskoj znanosti o evoluciji čovjeka.</p>
<p><strong>Kvocijent encefalizacije</strong> Mjera relativne težine mozga koja se dobiva kao omjer stvarne težine mozga i predviđene težine mozga kakvu bismo očekivali za vrstu određene težine tijela.</p>
<p><strong>Lucy Najpoznatiji <em>Australopitecus aferensis</em>, čiji je pronalazak doveo do bitnih spoznaja o toj vrsti, a jedna od njih je da su ti naši predci hodali uspravno i da su bili niskog rasta (nešto viši od jednog metra).</strong></p>
<p><strong>Opstetricijska dilema</strong> Svojevrsni konflikt između veličine lubanje novorođenčeta koja može dovesti u opasnost život rodilje te istovremeno može dovesti do veće adaptibilnosti djeteta s većom lubanjom. Navedeno znači da je morao postojati „kompromis" između veličine zdjelice majke i veličine djeteta da bi oboje uspješno preživjeli.</p>
<p><strong>Prirodni odabir Povećanje učestalosti pojedinih gena u populaciji koji su povezani s većom vjerojatnosti preživljanja, odnosno smanjenje učestalosti onih koji su povezani s manjom vjerojatnosti preživljavanja.</strong></p>
<p><strong>Umjetni odabir Promjene učestalosti pojedinih gena u populaciji pod utjecajem čovjeka.</strong></p>
<p><strong>Vrsta Skup genetski sličnih jedinki koje se mogu međusobno razmnožavati.</strong></p>
<p><strong>Literatura</strong></p>
<p><strong>Breedlove, S. M., &amp; Watson, N. V. (2013). <em>Evolution of the Brain and Behavior.</em> In S. M. Breedlove, &amp; N. V. Watson (Eds.), <em>Biological Psychology: An Introduction to Behavioral, Cognitive, and Clinical Neuroscience</em> (pp. 151-178). Sunderland, MA: Sinauer Associates, Inc. Publishers.</strong></p>
<p><strong>Buss, D. M. (2013). Sexual jealousy. <em>Psihologijske teme, 22</em>(2), 155-182.</strong></p>
<p><strong>Cairó, O. (2011). External measures of cognition. <em>Frontiers in human neuroscience</em>, <em>5</em>(108), 1-9.</strong></p>
<p>Dannemann, M., Andrés, A. M., Kelso, J. (2016). Introgression of Neandertal- and Denisovan-like Haplotypes Contributes to Adaptive Variation in Human Toll-like Receptors. <em>American Journal of Human Genetics</em>, <em>98</em>, (1), 22-33.</p>
<p><strong>Deschamps, M., Laval, G., Fagny, M., Itan, Y., Abel, L., Casanova, J. L., Ptin, E., Quintana-Murci, L. (2016). Genomic signatures of selective pressures and introgression from archaic hominins at human innate immunity genes. <em>The American Journal of Human Genetics, 98</em>(1), 5-21.</strong></p>
<p><strong>Geary, D. C. (2005). <em>The origin of mind: Evolution of brain, cognition, and general intelligence</em>. American Psychological Association.</strong></p>
<p><strong>Hofman, M. A. (2014). Evolution of the human brain: when bigger is better. <em>Frontiers in neuroanatomy</em>, <em>8</em>, 15.</strong></p>
<p>Johanson, D. i Edey, M. A. (1990). <em>Lucy: The beginnings of humankind</em>. New York, New York: Simon and Schuster.</p>
<p><strong>Kaas, J. H. (2012). The evolution of neocortex in primates. <em>Progress in brain research</em>, <em>195</em>, 91-102.</strong></p>
<p><strong>Kavoi, B. M., &amp; Jameela, H. (2011). Comparative morphometry of the olfactory bulb, tract and stria in the human, dog and goat. <em>International Journal of Morphology, 29</em>(3). 939-946.</strong></p>
<p>Nieuwenhuys, R., Ten Donkelaar, H. J. i Nicholson, C.<em> (1998). The Central Nervous System of Vertebrates.</em> Berlin, Germany: Springer.</p>
<p>Pinel, J. P. J. (2000). <em>Biološka psihologija</em>. Jastrebarsko: Naklada Slap.</p>
<p>Stone, V. E., Cosmides, L., Tooby, J., Kroll, N. i Knight, R. T. (2002). Selective impairment</p>
<p>of reasoning about social exchange in a patient with bilateral limbic system damage.</p>
<p><em>Proceedings of the National Academy of Sciences, 99</em>(17), 11531-11536.</p>
<p>Stringer, C. Why Have Our Brains Started to Shrink?</p>
<p>URL: https://www.scientificamerican.com/article/why-have-our-brains-started-to-shrink/</p>
<p><strong>Popis slika</strong></p>
<figure>
<img src="media/image1.jpeg" style="width:5.60472in;height:8.40299in" alt="" /><figcaption>C:\Users\Pavle\Desktop\Ilustracije\3.1.jpg</figcaption>
</figure>
<p>Slika. 3.1. Ilustracija evolucijskog stabla</p>
<figure>
<img src="media/image2.jpeg" style="width:5.1791in;height:7.76486in" alt="" /><figcaption>C:\Users\Pavle\Desktop\Ilustracije\3.2.jpg</figcaption>
</figure>
<p>Slika 3.2. Biološka kvalifikacija današnjeg čovjeka.</p>
<figure>
<img src="media/image3.jpeg" style="width:6.51042in;height:4.34689in" alt="" /><figcaption>C:\Users\Pavle\Desktop\Ilustracije\3.3.jpg</figcaption>
</figure>
<p>Slika 3.3. Pojednostavljen prikaz evolucije današnjeg čovjeka</p>
<figure>
<img src="media/image4.jpeg" style="width:6.5in;height:4.33333in" alt="" /><figcaption>C:\Users\Pavle\Desktop\Ilustracije\Pog3_fin\3.4\3.4.jpg</figcaption>
</figure>
<p>Slika 3.4. Pojednostavljen prikaz evolucije kralježnjaka</p>
<h2 id="references" class="page_break_before">References</h2>
<!-- Explicitly insert bibliography here -->
<div id="refs" role="doc-bibliography">

</div>
<!-- default theme -->

<style>
    /* import google fonts */
    @import url("https://fonts.googleapis.com/css?family=Open+Sans:400,600,700");
    @import url("https://fonts.googleapis.com/css?family=Source+Code+Pro");

    /* -------------------------------------------------- */
    /* global */
    /* -------------------------------------------------- */

    /* all elements */
    * {
        /* force sans-serif font unless specified otherwise */
        font-family: "Open Sans", "Helvetica", sans-serif;

        /* prevent text inflation on some mobile browsers */
        -webkit-text-size-adjust: none !important;
        -moz-text-size-adjust: none !important;
        -o-text-size-adjust: none !important;
        text-size-adjust: none !important;
    }

    @media only screen {
        /* "page" element */
        body {
            position: relative;
            box-sizing: border-box;
            font-size: 12pt;
            line-height: 1.5;
            max-width: 8.5in;
            margin: 20px auto;
            padding: 40px;
            border-radius: 5px;
            border: solid 1px #bdbdbd;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            background: #ffffff;
        }
    }

    /* when on screen < 8.5in wide */
    @media only screen and (max-width: 8.5in) {
        /* "page" element */
        body {
            padding: 20px;
            margin: 0;
            border-radius: 0;
            border: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05) inset;
            background: none;
        }
    }

    /* -------------------------------------------------- */
    /* headings */
    /* -------------------------------------------------- */

    /* all headings */
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
        margin: 20px 0;
        padding: 0;
        font-weight: bold;
    }

    /* biggest heading */
    h1 {
        margin: 40px 0;
        text-align: center;
    }

    /* second biggest heading */
    h2 {
        margin-top: 30px;
        padding-bottom: 5px;
        border-bottom: solid 1px #bdbdbd;
    }

    /* -------------------------------------------------- */
    /* manuscript header */
    /* -------------------------------------------------- */

    /* manuscript title */
    header > h1 {
        margin: 0;
    }

    /* manuscript title caption text (ie "automatically generated on") */
    header + p {
        text-align: center;
        margin-top: 10px;
    }

    /* -------------------------------------------------- */
    /* text elements */
    /* -------------------------------------------------- */

    /* links */
    a {
        color: #2196f3;
        overflow-wrap: break-word;
    }

    /* normal links (not empty, not button link, not syntax highlighting link) */
    a:not(:empty):not(.button):not(.sourceLine) {
        padding-left: 1px;
        padding-right: 1px;
    }

    /* superscripts and subscripts */
    sub,
    sup {
        /* prevent from affecting line height */
        line-height: 0;
    }

    /* unordered and ordered lists*/
    ul,
    ol {
        padding-left: 20px;
    }

    /* class for styling text semibold */
    .semibold {
        font-weight: 600;
    }

    /* class for styling elements horizontally left aligned */
    .left {
        display: block;
        text-align: left;
        margin-left: auto;
        margin-right: 0;
        justify-content: left;
    }

    /* class for styling elements horizontally centered */
    .center {
        display: block;
        text-align: center;
        margin-left: auto;
        margin-right: auto;
        justify-content: center;
    }

    /* class for styling elements horizontally right aligned */
    .right {
        display: block;
        text-align: right;
        margin-left: 0;
        margin-right: auto;
        justify-content: right;
    }

    /* -------------------------------------------------- */
    /* section elements */
    /* -------------------------------------------------- */

    /* horizontal divider line */
    hr {
        border: none;
        height: 1px;
        background: #bdbdbd;
    }

    /* paragraphs, horizontal dividers, figures, tables, code */
    p,
    hr,
    figure,
    table,
    pre {
        /* treat all as "paragraphs", with consistent vertical margins */
        margin-top: 20px;
        margin-bottom: 20px;
    }

    /* -------------------------------------------------- */
    /* figures */
    /* -------------------------------------------------- */

    /* figure */
    figure {
        max-width: 100%;
        margin-left: auto;
        margin-right: auto;
    }

    /* figure caption */
    figcaption {
        padding: 0;
        padding-top: 10px;
    }

    /* figure image element */
    figure img {
        max-width: 100%;
        display: block;
        margin-left: auto;
        margin-right: auto;
    }

    /* figure auto-number */
    img + figcaption > span:first-of-type {
        font-weight: bold;
        margin-right: 5px;
    }

    /* -------------------------------------------------- */
    /* tables */
    /* -------------------------------------------------- */

    /* table */
    table {
        border-collapse: collapse;
        border-spacing: 0;
        width: 100%;
        margin-left: auto;
        margin-right: auto;
    }

    /* table cells */
    th,
    td {
        border: solid 1px #bdbdbd;
        padding: 10px;
        /* squash table if too wide for page by forcing line breaks */
        overflow-wrap: break-word;
    }

    /* header row and even rows */
    th,
    tr:nth-child(2n) {
        background-color: #fafafa;
    }

    /* odd rows */
    tr:nth-child(2n + 1) {
        background-color: #ffffff;
    }

    /* table caption */
    caption {
        text-align: left;
        padding: 0;
        padding-bottom: 10px;
    }

    /* table auto-number */
    table > caption > span:first-of-type,
    div.table_wrapper > table > caption > span:first-of-type {
        font-weight: bold;
        margin-right: 5px;
    }

    /* -------------------------------------------------- */
    /* code */
    /* -------------------------------------------------- */

    /* multi-line code block */
    pre {
        padding: 10px;
        background-color: #eeeeee;
        color: #000000;
        border-radius: 5px;
        break-inside: avoid;
        text-align: left;
    }

    /* inline code, ie code within normal text */
    :not(pre) > code {
        padding: 0 4px;
        background-color: #eeeeee;
        color: #000000;
        border-radius: 5px;
    }

    /* code text */
    /* apply all children, to reach syntax highlighting sub-elements */
    code,
    code * {
        /* force monospace font */
        font-family: "Source Code Pro", "Courier New", monospace;
    }

    /* -------------------------------------------------- */
    /* quotes */
    /* -------------------------------------------------- */

    /* quoted text */
    blockquote {
        margin: 0;
        padding: 0;
        border-left: 4px solid #bdbdbd;
        padding-left: 16px;
        break-inside: avoid;
    }

    /* -------------------------------------------------- */
    /* banners */
    /* -------------------------------------------------- */

    /* info banners */
    .banner {
        box-sizing: border-box;
        display: block;
        position: relative;
        width: 100%;
        margin-top: 20px;
        margin-bottom: 20px;
        padding: 20px;
        text-align: center;
    }

    /* paragraph in banner */
    .banner > p {
        margin: 0;
    }

    /* -------------------------------------------------- */
    /* highlight colors */
    /* -------------------------------------------------- */

    .white {
        background: #ffffff;
    }
    .lightgrey {
        background: #eeeeee;
    }
    .grey {
        background: #757575;
    }
    .darkgrey {
        background: #424242;
    }
    .black {
        background: #000000;
    }
    .lightred {
        background: #ffcdd2;
    }
    .lightyellow {
        background: #ffecb3;
    }
    .lightgreen {
        background: #dcedc8;
    }
    .lightblue {
        background: #e3f2fd;
    }
    .lightpurple {
        background: #f3e5f5;
    }
    .red {
        background: #f44336;
    }
    .orange {
        background: #ff9800;
    }
    .yellow {
        background: #ffeb3b;
    }
    .green {
        background: #4caf50;
    }
    .blue {
        background: #2196f3;
    }
    .purple {
        background: #9c27b0;
    }
    .white,
    .lightgrey,
    .lightred,
    .lightyellow,
    .lightgreen,
    .lightblue,
    .lightpurple,
    .orange,
    .yellow,
    .white a,
    .lightgrey a,
    .lightred a,
    .lightyellow a,
    .lightgreen a,
    .lightblue a,
    .lightpurple a,
    .orange a,
    .yellow a {
        color: #000000;
    }
    .grey,
    .darkgrey,
    .black,
    .red,
    .green,
    .blue,
    .purple,
    .grey a,
    .darkgrey a,
    .black a,
    .red a,
    .green a,
    .blue a,
    .purple a {
        color: #ffffff;
    }

    /* -------------------------------------------------- */
    /* buttons */
    /* -------------------------------------------------- */

    /* class for styling links like buttons */
    .button {
        display: inline-flex;
        justify-content: center;
        align-items: center;
        margin: 5px;
        padding: 10px 20px;
        font-size: 0.75em;
        font-weight: 600;
        text-transform: uppercase;
        text-decoration: none;
        letter-spacing: 1px;
        background: none;
        color: #2196f3;
        border: solid 1px #bdbdbd;
        border-radius: 5px;
    }

    /* buttons when hovered */
    .button:hover:not([disabled]),
    .icon_button:hover:not([disabled]) {
        cursor: pointer;
        background: #f5f5f5;
    }

    /* buttons when disabled */
    .button[disabled],
    .icon_button[disabled] {
        opacity: 0.35;
        pointer-events: none;
    }

    /* class for styling buttons containg only single icon */
    .icon_button {
        display: inline-flex;
        justify-content: center;
        align-items: center;
        text-decoration: none;
        margin: 0;
        padding: 0;
        background: none;
        border-radius: 5px;
        border: none;
        width: 20px;
        height: 20px;
        min-width: 20px;
        min-height: 20px;
    }

    /* icon button inner svg image */
    .icon_button > svg {
        height: 16px;
    }

    /* -------------------------------------------------- */
    /* icons */
    /* -------------------------------------------------- */

    /* class for styling icons inline with text */
    .inline_icon {
        height: 1em;
        position: relative;
        top: 0.125em;
    }

    /* -------------------------------------------------- */
    /* print control */
    /* -------------------------------------------------- */

    @media print {
        @page {
            /* suggested printing margin */
            margin: 0.5in;
        }

        /* document and "page" elements */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }

        /* "page" element */
        body {
            font-size: 11pt !important;
            line-height: 1.35;
        }

        /* all headings */
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            margin: 15px 0;
        }

        /* heading 1 */
        h1 {
            font-size: 1.75em;
        }

        /* heading 2 */
        h2 {
            font-size: 1.25em;
            margin-top: 0;
        }

        /* heading 3 */
        h3 {
            font-size: 1.10em;
        }

        /* figures and tables */
        figure, table {
            font-size: 0.85em;
        }

        /* table cells */
        th,
        td {
            padding: 5px;
        }

        /* shrink font awesome icons */
        i.fas,
        i.fab,
        i.far,
        i.fal {
            transform: scale(0.85);
        }

        /* decrease banner margins */
        .banner {
            margin-top: 15px;
            margin-bottom: 15px;
            padding: 15px;
        }

        /* class for centering an element vertically on its own page */
        .page_center {
            margin: auto;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            vertical-align: middle;
            break-before: page;
            break-after: page;
        }

        /* always insert a page break before the element */
        .page_break_before {
            break-before: page;
        }

        /* always insert a page break after the element */
        .page_break_after {
            break-after: page;
        }

        /* avoid page break before the element */
        .page_break_before_avoid {
            break-before: avoid;
        }

        /* avoid page break after the element */
        .page_break_after_avoid {
            break-after: avoid;
        }

        /* avoid page break inside the element */
        .page_break_inside_avoid {
            break-inside: avoid;
        }
    }

    /* -------------------------------------------------- */
    /* override pandoc css quirks */
    /* -------------------------------------------------- */

    .sourceCode {
        /* prevent unsightly overflow in wide code blocks */
        overflow: auto !important;
    }

    div.sourceCode {
        /* prevent background fill on top-most code block  container */
        background: none !important;
    }

    .sourceCode * {
        /* force consistent line spacing */
        line-height: 1.5 !important;
    }

    div.sourceCode {
        /* style code block margins same as <pre> element */
        margin-top: 20px;
        margin-bottom: 20px;
    }

    /* -------------------------------------------------- */
    /* mathjax */
    /* -------------------------------------------------- */

    /* mathjax containers */
    .math.display > span:not(.MathJax_Preview) {
        /* turn inline element (no dimensions) into block (allows fixed width and thus scrolling) */
        display: flex !important;
        overflow-x: auto !important;
        overflow-y: hidden !important;
        justify-content: center;
        align-items: center;
        margin: 0 !important;
    }

    /* right click menu */
    .MathJax_Menu {
        border-radius: 5px !important;
        border: solid 1px #bdbdbd !important;
        box-shadow: none !important;
    }

    /* equation auto-number */
    span[id^="eq:"] > span.math.display + span {
        font-weight: 600;
    }

    /* equation */
    span[id^="eq:"] > span.math.display > span {
        /* nudge to make room for equation auto-number */
        margin-right: 40px !important;
    }

    /* -------------------------------------------------- */
    /* table scroll plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* table wrapper */
        .table_wrapper {
            /* show scrollbar on tables if necessary to prevent overflow */
            overflow: auto;
            width: 100%;
            margin: 20px 0;
        }

        /* table within table wrapper */
        .table_wrapper table,
        .table_wrapper table * {
            /* don't break table words */
            word-break: normal !important;
        }

        .table_wrapper > table {
            /* move margins from table to table_wrapper to allow margin collapsing */
            margin: 0;
        }
    }

    /* -------------------------------------------------- */
    /* anchors plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* anchor button */
        .anchor {
            opacity: 0;
            margin-left: 5px;
        }

        /* anchor buttons within <h2>'s */
        h2 .anchor {
            margin-left: 10px;
        }

        /* anchor buttons when hovered/focused and anything containing an anchor button when hovered */
        *:hover > .anchor,
        .anchor:hover,
        .anchor:focus {
            opacity: 1;
        }

        /* anchor button when hovered */
        .anchor:hover {
            cursor: pointer;
        }
    }

    /* always show anchor button on devices with no mouse/hover ability */
    @media (hover: none) {
        .anchor {
            opacity: 1;
        }
    }

    /* always hide anchor button on print */
    @media only print {
        .anchor {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* accordion plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* accordion arrow button */
        .accordion_arrow {
            margin-right: 10px;
        }

        /* arrow icon when <h2> data-collapsed attribute true */
        h2[data-collapsed="true"] > .accordion_arrow > svg {
            transform: rotate(-90deg);
        }

        /* all elements (except <h2>'s) when data-collapsed attribute true */
        *:not(h2)[data-collapsed="true"] {
            display: none;
        }

        /* accordion arrow button when hovered and <h2>'s when hovered */
        .accordion_arrow:hover,
        h2[data-collapsed="true"]:hover,
        h2[data-collapsed="false"]:hover {
            cursor: pointer;
        }
    }

    /* always hide accordion arrow button on print */
    @media only print {
        .accordion_arrow {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* tooltips plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* tooltip container */
        #tooltip {
            position: absolute;
            width: 50%;
            min-width: 240px;
            max-width: 75%;
            z-index: 1;
        }

        /* tooltip content */
        #tooltip_content {
            margin-bottom: 5px;
            padding: 20px;
            border-radius: 5px;
            border: solid 1px #bdbdbd;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            background: #ffffff;
            overflow-wrap: break-word;
        }

        /* tooltip copy of paragraphs and figures */
        #tooltip_content > p,
        #tooltip_content > figure {
            margin: 0;
            max-height: 320px;
            overflow-y: auto;
        }

        /* tooltip copy of <img> */
        #tooltip_content > figure > img {
            max-height: 260px;
        }

        /* navigation bar */
        #tooltip_nav_bar {
            margin-top: 10px;
            text-align: center;
        }

        /* navigation bar previous/next buton */
        #tooltip_nav_bar > .icon_button {
            position: relative;
            top: 3px;
        }

        /* navigation bar previous button */
        #tooltip_nav_bar > .icon_button:first-of-type {
            margin-right: 5px;
        }

        /* navigation bar next button */
        #tooltip_nav_bar > .icon_button:last-of-type {
            margin-left: 5px;
        }
    }

    /* always hide tooltip on print */
    @media only print {
        #tooltip {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* jump to first plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* jump button */
        .jump_arrow {
            position: relative;
            top: 0.125em;
            margin-right: 5px;
        }
    }

    /* always hide jump button on print */
    @media only print {
        .jump_arrow {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* link highlight plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* anything with data-highlighted attribute true */
        [data-highlighted="true"] {
            background: #ffeb3b;
        }

        /* anything with data-selected attribute true */
        [data-selected="true"] {
            background: #ff8a65 !important;
        }

        /* animation definition for glow */
        @keyframes highlight_glow {
            0% {
                background: none;
            }
            10% {
                background: #bbdefb;
            }
            100% {
                background: none;
            }
        }

        /* anything with data-glow attribute true */
        [data-glow="true"] {
            animation: highlight_glow 2s;
        }
    }

    /* -------------------------------------------------- */
    /* table of contents plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* toc panel */
        #toc_panel {
            box-sizing: border-box;
            position: fixed;
            top: 0;
            left: 0;
            background: #ffffff;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            z-index: 2;
        }

        /* toc panel when closed */
        #toc_panel[data-open="false"] {
            min-width: 60px;
            width: 60px;
            height: 60px;
            border-right: solid 1px #bdbdbd;
            border-bottom: solid 1px #bdbdbd;
        }

        /* toc panel when open */
        #toc_panel[data-open="true"] {
            min-width: 260px;
            max-width: 480px;
            /* keep panel edge consistent distance away from "page" edge */
            width: calc(((100vw - 8.5in) / 2) - 30px - 40px);
            bottom: 0;
            border-right: solid 1px #bdbdbd;
        }

        /* toc panel header */
        #toc_header {
            box-sizing: border-box;
            display: flex;
            flex-direction: row;
            align-items: center;
            height: 60px;
            margin: 0;
            padding: 20px;
        }

        /* toc panel header when hovered */
        #toc_header:hover {
            cursor: pointer;
        }

        /* toc panel header when panel open */
        #toc_panel[data-open="true"] > #toc_header {
            border-bottom: solid 1px #bdbdbd;
        }

        /* toc open/close header button */
        #toc_button {
            margin-right: 20px;
        }

        /* hide toc list and header text when closed */
        #toc_panel[data-open="false"] > #toc_header > *:not(#toc_button),
        #toc_panel[data-open="false"] > #toc_list {
            display: none;
        }

        /* toc list of entries */
        #toc_list {
            box-sizing: border-box;
            width: 100%;
            padding: 20px;
            position: absolute;
            top: calc(60px + 1px);
            bottom: 0;
            overflow: auto;
        }

        /* toc entry, link to section in document */
        .toc_link {
            display: block;
            padding: 5px;
            position: relative;
            font-weight: 600;
            text-decoration: none;
        }

        /* toc entry when hovered or when "viewed" */
        .toc_link:hover,
        .toc_link[data-viewing="true"] {
            background: #f5f5f5;
        }

        /* toc entry, level 1 indentation */
        .toc_link[data-level="1"] {
            margin-left: 0;
        }

        /* toc entry, level 2 indentation */
        .toc_link[data-level="2"] {
            margin-left: 20px;
        }

        /* toc entry, level 3 indentation */
        .toc_link[data-level="3"] {
            margin-left: 40px;
        }

        /* toc entry, level 4 indentation */
        .toc_link[data-level="4"] {
            margin-left: 60px;
        }

        /* toc entry bullets */
        #toc_panel[data-bullets="true"] .toc_link[data-level]:before {
            position: absolute;
            left: -15px;
            top: -1px;
            font-size: 1.5em;
        }

        /* toc entry, level 2 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="2"]:before {
            content: "\2022";
        }

        /* toc entry, level 3 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="3"]:before {
            content: "\25AB";
        }

        /* toc entry, level 4 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="4"]:before {
            content: "-";
        }
    }

    /* when on screen < 8.5in wide */
    @media only screen and (max-width: 8.5in) {
        /* push <body> ("page") element down to make room for toc icon */
        .toc_body_nudge {
            padding-top: 60px;
        }

        /* toc icon when panel closed and not hovered */
        #toc_panel[data-open="false"]:not(:hover) {
            background: rgba(255, 255, 255, 0.75);
        }
    }

    /* always hide toc panel on print */
    @media only print {
        #toc_panel {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* lightbox plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* regular <img> in document when hovered */
        .lightbox_document_img:hover {
            cursor: pointer;
        }

        .body_no_scroll {
            overflow: hidden !important;
        }

        /* screen overlay */
        #lightbox_overlay {
            display: flex;
            flex-direction: column;
            position: fixed;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            z-index: 3;
        }

        /* middle area containing lightbox image */
        #lightbox_image_container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            padding: 20px;
        }

        /* bottom area containing caption */
        #lightbox_bottom_container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            min-height: 100px;
            max-height: 100px;
            background: rgba(0, 0, 0, 0.5);
        }

        /* image number info text box */
        #lightbox_number_info {
            position: absolute;
            color: #ffffff;
            font-weight: 600;
            left: 2px;
            top: 0;
            z-index: 4;
        }

        /* zoom info text box */
        #lightbox_zoom_info {
            position: absolute;
            color: #ffffff;
            font-weight: 600;
            right: 2px;
            top: 0;
            z-index: 4;
        }

        /* copy of image caption */
        #lightbox_caption {
            box-sizing: border-box;
            display: inline-block;
            width: 100%;
            max-height: 100%;
            padding: 10px 0;
            text-align: center;
            overflow-y: auto;
            color: #ffffff;
        }

        /* navigation previous/next button */
        .lightbox_button {
            width: 100px;
            height: 100%;
            min-width: 100px;
            min-height: 100%;
            color: #ffffff;
        }

        /* navigation previous/next button when hovered */
        .lightbox_button:hover {
            background: none !important;
        }

        /* navigation button icon */
        .lightbox_button > svg {
            height: 25px;
        }

        /* figure auto-number */
        #lightbox_caption > span:first-of-type {
            font-weight: bold;
            margin-right: 5px;
        }

        /* lightbox image when hovered */
        #lightbox_img:hover {
            cursor: grab;
        }

        /* lightbox image when grabbed */
        #lightbox_img:active {
            cursor: grabbing;
        }
    }

    /* when on screen < 480px wide */
    @media only screen and (max-width: 480px) {
        /* make navigation buttons skinnier on small screens to make more room for caption text */
        .lightbox_button {
            width: 50px;
            min-width: 50px;
        }
    }

    /* always hide lightbox on print */
    @media only print {
        #lightbox_overlay {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* hypothesis (annotations) plugin */
    /* -------------------------------------------------- */

    /* side panel */
    .annotator-frame {
        width: 280px !important;
        z-index: 0 !important;
    }

    /* match highlight color to rest of theme */
    .annotator-highlights-always-on .annotator-hl {
        background-color: #ffeb3b !important;
    }

    /* match focused color to rest of theme */
    .annotator-hl.annotator-hl-focused {
        background-color: #ff8a65 !important;
    }

    /* match bucket bar color to rest of theme */
    .annotator-bucket-bar {
        background: #f5f5f5 !important;
    }

    /* always hide toolbar and tooltip on print */
    @media only print {
        .annotator-frame {
            display: none !important;
        }

        hypothesis-adder {
            display: none !important;
        }
    }
</style>
<!-- table scroll plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin allows tables that are too wide to fit within
        // the page to have a scrollbar instead of being squashed to fit.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'tableScroll';

        // default plugin options
        const options = {
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // wrap each table in a container
            const tables = document.querySelectorAll('table');
            for (const table of tables)
                wrapElement(table).classList.add('table_wrapper');
            // table_wrapper CSS class in theme file provides scroll
            // functionality
        }

        // wrap element in div and return div
        function wrapElement(element) {
            const parent = element.parentNode;
            const wrapper = document.createElement('div');
            parent.replaceChild(wrapper, element);
            wrapper.appendChild(element);
            return wrapper;
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>
<!-- anchors plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin adds an anchor next to each of a certain type
        // of element that provides a human-readable url to that specific
        // item/position in the document (eg "manuscript.html#abstract"). It
        // also makes it such that scrolling out of view of a target removes
        // its identifier from the url.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'anchors';

        // default plugin options
        const options = {
            // which types of elements to add anchors next to, in
            // "document.querySelector" format
            typesQuery: 'h1, h2, h3, figure, table',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // add anchor to each element of specified types
            const elements = document.querySelectorAll(options.typesQuery);
            for (const element of elements)
                addAnchor(element);

            // attach scroll listener to window
            window.addEventListener('scroll', onScroll);
        }

        // when window is scrolled
        function onScroll() {
            // if url has hash and user has scrolled out of view of hash
            // target, remove hash from url
            const target = getHashTarget();
            if (target) {
                if (
                    target.getBoundingClientRect().top > window.innerHeight ||
                    target.getBoundingClientRect().bottom < 0
                )
                    history.pushState(null, null, ' ');
            }
        }

        // add anchor to element
        function addAnchor(element) {
            let withId; // element with unique id
            let addTo; // element to add anchor button to

            // if figure or table, modify withId and addTo to get expected
            // elements
            if (element.tagName.toLowerCase() === 'figure') {
                withId = element.querySelector('img');
                addTo = element.querySelector('figcaption');
            } else if (element.tagName.toLowerCase() === 'table') {
                withId =
                    element.previousElementSibling ||
                    element.parentNode.previousElementSibling;
                addTo = element.querySelector('caption');
            }

            withId = withId || element;
            addTo = addTo || element;
            const id = withId.id || withId.name || null;

            // do not add anchor if element doesn't have assigned id.
            // id is generated by pandoc and is assumed to be unique and
            // human-readable
            if (!id)
                return;

            // create anchor button
            const anchor = document.createElement('a');
            anchor.innerHTML = document.querySelector('.icon_link').innerHTML;
            anchor.title = 'Link to this part of the document';
            anchor.classList.add('icon_button', 'anchor');
            anchor.dataset.ignore = 'true';
            anchor.href = '#' + id;
            addTo.appendChild(anchor);
        }

        // get element that is target of link or url hash
        function getHashTarget() {
            const hash = window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector(
                '[id="' + id + '"], [name="' + id + '"]'
            );
            if (!target)
                return;

            // if figure or table, modify target to get expected element
            if (hash.indexOf('#fig:') === 0)
                target = target.parentNode;
            if (hash.indexOf('#tbl:') === 0)
                target = target.nextElementSibling;

            return target;
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- link icon -->

<template class="icon_link">
    <!-- modified from: https://fontawesome.com/icons/link -->
    <svg width="16" height="16" viewBox="0 0 512 512">
        <path
            fill="currentColor"
            d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"
        ></path>
    </svg>
</template>
<!-- accordion plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin allows sections of content under <h2> headings
        // to be collapsible.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'accordion';

        // default plugin options
        const options = {
            // whether to always start expanded ('false'), always start
            // collapsed ('true'), or start collapsed when screen small ('auto')
            startCollapsed: 'auto',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // run through each <h2> heading
            const headings = document.querySelectorAll('h2');
            for (const heading of headings) {
                addArrow(heading);

                // start expanded/collapsed based on option
                if (
                    options.startCollapsed === 'true' ||
                    (options.startCollapsed === 'auto' && isSmallScreen())
                )
                    collapseHeading(heading);
                else
                    expandHeading(heading);
            }

            // attach hash change listener to window
            window.addEventListener('hashchange', onHashChange);
        }

        // when hash (eg manuscript.html#introduction) changes
        function onHashChange() {
            const target = getHashTarget();
            if (target)
                goToElement(target);
        }

        // add arrow to heading
        function addArrow(heading) {
            // add arrow button
            const arrow = document.createElement('button');
            arrow.innerHTML = document.querySelector(
                '.icon_angle_down'
            ).innerHTML;
            arrow.classList.add('icon_button', 'accordion_arrow');
            heading.insertBefore(arrow, heading.firstChild);

            // attach click listener to heading and button
            heading.addEventListener('click', onHeadingClick);
            arrow.addEventListener('click', onArrowClick);
        }

        // determine if on mobile-like device with small screen
        function isSmallScreen() {
            return Math.min(window.innerWidth, window.innerHeight) < 480;
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // get element that is target of hash
        function getHashTarget(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector(
                '[id="' + id + '"], [name="' + id + '"]'
            );
            if (!target)
                return;

            // if figure or table, modify target to get expected element
            if (hash.indexOf('#fig:') === 0)
                target = target.parentNode;
            if (hash.indexOf('#tbl:') === 0)
                target = target.nextElementSibling;

            return target;
        }

        // when <h2> heading is clicked
        function onHeadingClick(event) {
            // only collapse if <h2> itself is target of click (eg, user did
            // not click on anchor within <h2>)
            if (event.target === this)
                toggleCollapse(this);
        }

        // when arrow button is clicked
        function onArrowClick() {
            toggleCollapse(this.parentNode);
        }

        // collapse section if expanded, expand if collapsed
        function toggleCollapse(heading) {
            if (heading.dataset.collapsed === 'false')
                collapseHeading(heading);
            else
                expandHeading(heading);
        }

        // elements to exclude from collapse, such as table of contents panel,
        // hypothesis panel, etc
        const exclude = '#toc_panel, div.annotator-frame, #lightbox_overlay';

        // collapse section
        function collapseHeading(heading) {
            heading.setAttribute('data-collapsed', 'true');
            const children = getChildren(heading);
            for (const child of children)
                child.setAttribute('data-collapsed', 'true');
        }

        // expand section
        function expandHeading(heading) {
            heading.setAttribute('data-collapsed', 'false');
            const children = getChildren(heading);
            for (const child of children)
                child.setAttribute('data-collapsed', 'false');
        }

        // get list of elements between this <h2> and next <h2> or <h1>
        // ("children" of the <h2> section)
        function getChildren(heading) {
            return nextUntil(heading, 'h2, h1', exclude);
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get list of elements after a start element up to element matching
        // query
        function nextUntil(element, query, exclude) {
            const elements = [];
            while (element = element.nextElementSibling, element) {
                if (element.matches(query))
                    break;
                if (!element.matches(exclude))
                    elements.push(element);
            }
            return elements;
        }

        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- angle down icon -->

<template class="icon_angle_down">
    <!-- modified from: https://fontawesome.com/icons/angle-down -->
    <svg width="16" height="16" viewBox="0 0 448 512">
        <path
            fill="currentColor"
            d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"
        ></path>
    </svg>
</template>
<!-- tooltips plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when the user hovers or
        // focuses a link to a citation or figure, a tooltip appears with a
        // preview of the reference content, along with arrows to navigate
        // between instances of the same reference in the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'tooltips';

        // default plugin options
        const options = {
            // whether user must click off to close tooltip instead of just
            // un-hovering
            clickClose: 'false',
            // delay (in ms) between opening and closing tooltip
            delay: '100',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            const links = getLinks();
            for (const link of links) {
                // attach hover and focus listeners to link
                link.addEventListener('mouseover', onLinkHover);
                link.addEventListener('mouseleave', onLinkUnhover);
                link.addEventListener('focus', onLinkFocus);
                link.addEventListener('touchend', onLinkTouch);
            }

            // attach mouse, key, and resize listeners to window
            window.addEventListener('mousedown', onClick);
            window.addEventListener('touchstart', onClick);
            window.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onResize);
        }

        // when link is hovered
        function onLinkHover() {
            // function to open tooltip
            const delayOpenTooltip = function() {
                openTooltip(this);
            }.bind(this);

            // run open function after delay
            this.openTooltipTimer = window.setTimeout(
                delayOpenTooltip,
                options.delay
            );
        }

        // when mouse leaves link
        function onLinkUnhover() {
            // cancel opening tooltip
            window.clearTimeout(this.openTooltipTimer);

            // don't close on unhover if option specifies
            if (options.clickClose === 'true')
                return;

            // function to close tooltip
            const delayCloseTooltip = function() {
                // if tooltip open and if mouse isn't over tooltip, close
                const tooltip = document.getElementById('tooltip');
                if (tooltip && !tooltip.matches(':hover'))
                    closeTooltip();
            };

            // run close function after delay
            this.closeTooltipTimer = window.setTimeout(
                delayCloseTooltip,
                options.delay
            );
        }

        // when link is focused (tabbed to)
        function onLinkFocus(event) {
            openTooltip(this);
        }

        // when link is touched on touch screen
        function onLinkTouch(event) {
            // attempt to force hover state on first tap always, and trigger
            // regular link click (and navigation) on second tap
            if (event.target === document.activeElement)
                event.target.click();
            else {
                document.activeElement.blur();
                event.target.focus();
            }
            if (event.cancelable)
                event.preventDefault();
            event.stopPropagation();
            return false;
        }

        // when mouse is clicked anywhere in window
        function onClick(event) {
            closeTooltip();
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            switch (event.key) {
                // trigger click of prev button
                case 'ArrowLeft':
                    const prevButton = document.getElementById(
                        'tooltip_prev_button'
                    );
                    if (prevButton)
                        prevButton.click();
                    break;
                // trigger click of next button
                case 'ArrowRight':
                    const nextButton = document.getElementById(
                        'tooltip_next_button'
                    );
                    if (nextButton)
                        nextButton.click();
                    break;
                // close on esc
                case 'Escape':
                    closeTooltip();
                    break;
            }
        }

        // when window is resized or zoomed
        function onResize() {
            closeTooltip();
        }

        // get all links of types we wish to handle
        function getLinks() {
            const queries = [];
            // exclude buttons, anchor links, toc links, etc
            const exclude =
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            queries.push('a[href^="#ref-"]' + exclude); // citation links
            queries.push('a[href^="#fig:"]' + exclude); // figure links
            const query = queries.join(', ');
            return document.querySelectorAll(query);
        }

        // get links with same target, get index of link in set, get total
        // same links
        function getSameLinks(link) {
            const sameLinks = [];
            const links = getLinks();
            for (const otherLink of links) {
                if (
                    otherLink.getAttribute('href') === link.getAttribute('href')
                )
                    sameLinks.push(otherLink);
            }

            return {
                elements: sameLinks,
                index: sameLinks.indexOf(link),
                total: sameLinks.length
            };
        }

        // open tooltip
        function openTooltip(link) {
            // delete tooltip if it exists, start fresh
            closeTooltip();

            // make tooltip element
            const tooltip = makeTooltip(link);

            // if source couldn't be found and tooltip not made, exit
            if (!tooltip)
                return;

            // make navbar elements
            const navBar = makeNavBar(link);
            if (navBar)
                tooltip.firstElementChild.appendChild(navBar);

            // attach tooltip to page
            document.body.appendChild(tooltip);

            // position tooltip
            const position = function() {
                positionTooltip(link);
            };
            position();

            // if tooltip contains images, position again after they've loaded
            const imgs = tooltip.querySelectorAll('img');
            for (const img of imgs)
                img.addEventListener('load', position);
        }

        // close (delete) tooltip
        function closeTooltip() {
            const tooltip = document.getElementById('tooltip');
            if (tooltip)
                tooltip.remove();
        }

        // make tooltip
        function makeTooltip(link) {
            // get target element that link points to
            const source = getSource(link);

            // if source can't be found, exit
            if (!source)
                return;

            // create new tooltip
            const tooltip = document.createElement('div');
            tooltip.id = 'tooltip';
            const tooltipContent = document.createElement('div');
            tooltipContent.id = 'tooltip_content';
            tooltip.appendChild(tooltipContent);

            // make copy of source node and put in tooltip
            const sourceCopy = makeCopy(source);
            tooltipContent.appendChild(sourceCopy);

            // attach mouse event listeners
            tooltip.addEventListener('click', onTooltipClick);
            tooltip.addEventListener('mousedown', onTooltipClick);
            tooltip.addEventListener('touchstart', onTooltipClick);
            tooltip.addEventListener('mouseleave', onTooltipUnhover);

            // (for interaction with lightbox plugin)
            // transfer click on tooltip copied img to original img
            const sourceImg = source.querySelector('img');
            const sourceCopyImg = sourceCopy.querySelector('img');
            if (sourceImg && sourceCopyImg) {
                const clickImg = function() {
                    sourceImg.click();
                    closeTooltip();
                };
                sourceCopyImg.addEventListener('click', clickImg);
            }

            return tooltip;
        }

        // make carbon copy of html dom element
        function makeCopy(source) {
            const sourceCopy = source.cloneNode(true);

            // delete elements marked with ignore (eg anchor and jump buttons)
            const deleteFromCopy = sourceCopy.querySelectorAll(
                '[data-ignore="true"]'
            );
            for (const element of deleteFromCopy)
                element.remove();

            // delete certain element attributes
            const attributes = [
                'id',
                'data-collapsed',
                'data-selected',
                'data-highlighted',
                'data-glow'
            ];
            for (const attribute of attributes) {
                sourceCopy.removeAttribute(attribute);
                const elements = sourceCopy.querySelectorAll(
                    '[' + attribute + ']'
                );
                for (const element of elements)
                    element.removeAttribute(attribute);
            }

            return sourceCopy;
        }

        // when tooltip is clicked
        function onTooltipClick(event) {
            // when user clicks on tooltip, stop click from transferring
            // outside of tooltip (eg, click off to close tooltip, or eg click
            // off to unhighlight same refs)
            event.stopPropagation();
        }

        // when tooltip is unhovered
        function onTooltipUnhover(event) {
            if (options.clickClose === 'true')
                return;

            // make sure new mouse/touch/focus no longer over tooltip or any
            // element within it
            const tooltip = document.getElementById('tooltip');
            if (!tooltip)
                return;
            if (this.contains(event.relatedTarget))
                return;

            closeTooltip();
        }

        // make nav bar to go betwen prev/next instances of same reference
        function makeNavBar(link) {
            // find other links to the same source
            const sameLinks = getSameLinks(link);

            // don't show nav bar when singular reference
            if (sameLinks.total <= 1)
                return;

            // find prev/next links with same target
            const prevLink = getPrevLink(link, sameLinks);
            const nextLink = getNextLink(link, sameLinks);

            // create nav bar
            const navBar = document.createElement('div');
            navBar.id = 'tooltip_nav_bar';
            const text = sameLinks.index + 1 + ' of ' + sameLinks.total;

            // create nav bar prev/next buttons
            const prevButton = document.createElement('button');
            const nextButton = document.createElement('button');
            prevButton.id = 'tooltip_prev_button';
            nextButton.id = 'tooltip_next_button';
            prevButton.title =
                'Jump to the previous occurence of this item in the document [←]';
            nextButton.title =
                'Jump to the next occurence of this item in the document [→]';
            prevButton.classList.add('icon_button');
            nextButton.classList.add('icon_button');
            prevButton.innerHTML = document.querySelector(
                '.icon_caret_left'
            ).innerHTML;
            nextButton.innerHTML = document.querySelector(
                '.icon_caret_right'
            ).innerHTML;
            navBar.appendChild(prevButton);
            navBar.appendChild(document.createTextNode(text));
            navBar.appendChild(nextButton);

            // attach click listeners to buttons
            prevButton.addEventListener('click', function() {
                onPrevNextClick(link, prevLink);
            });
            nextButton.addEventListener('click', function() {
                onPrevNextClick(link, nextLink);
            });

            return navBar;
        }

        // get previous link with same target
        function getPrevLink(link, sameLinks) {
            if (!sameLinks)
                sameLinks = getSameLinks(link);
            // wrap index to other side if < 1
            let index;
            if (sameLinks.index - 1 >= 0)
                index = sameLinks.index - 1;
            else
                index = sameLinks.total - 1;
            return sameLinks.elements[index];
        }

        // get next link with same target
        function getNextLink(link, sameLinks) {
            if (!sameLinks)
                sameLinks = getSameLinks(link);
            // wrap index to other side if > total
            let index;
            if (sameLinks.index + 1 <= sameLinks.total - 1)
                index = sameLinks.index + 1;
            else
                index = 0;
            return sameLinks.elements[index];
        }

        // get element that is target of link or url hash
        function getSource(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector(
                '[id="' + id + '"], [name="' + id + '"]'
            );
            if (!target)
                return;

            // if figure or table, modify target to get expected element
            if (hash.indexOf('#ref-') === 0)
                target = target.querySelector('p');
            else if (hash.indexOf('#fig:') === 0)
                target = target.parentNode;
            else if (hash.indexOf('#tbl:') === 0)
                return;

            return target;
        }

        // when prev/next arrow button is clicked
        function onPrevNextClick(link, prevNextLink) {
            if (link && prevNextLink)
                goToElement(prevNextLink, window.innerHeight * 0.5);
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // determine position to place tooltip based on link position in
        // viewport and tooltip size
        function positionTooltip(link, left, top) {
            const tooltipElement = document.getElementById('tooltip');
            if (!tooltipElement)
                return;

            // get convenient vars for position/dimensions of
            // link/tooltip/page/view
            link = getRectInPage(link);
            const tooltip = getRectInPage(tooltipElement);
            const view = getRectInPage();

            // horizontal positioning
            if (left)
                // use explicit value
                left = left;
            else if (link.left + tooltip.width < view.right)
                // fit tooltip to right of link
                left = link.left;
            else if (link.right - tooltip.width > view.left)
                // fit tooltip to left of link
                left = link.right - tooltip.width;
            // center tooltip in view
            else
                left = (view.right - view.left) / 2 - tooltip.width / 2;

            // vertical positioning
            if (top)
                // use explicit value
                top = top;
            else if (link.top - tooltip.height > view.top)
                // fit tooltip above link
                top = link.top - tooltip.height;
            else if (link.bottom + tooltip.height < view.bottom)
                // fit tooltip below link
                top = link.bottom;
            else {
                // center tooltip in view
                top = view.top + view.height / 2 - tooltip.height / 2;
                // nudge off of link to left/right if possible
                if (link.right + tooltip.width < view.right)
                    left = link.right;
                else if (link.left - tooltip.width > view.left)
                    left = link.left - tooltip.width;
            }

            tooltipElement.style.left = left + 'px';
            tooltipElement.style.top = top + 'px';
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get position of element relative to page
        function getRectInPage(element) {
            const rect = getRectInView(element);
            const body = getRectInView(document.body);

            const newRect = {};
            newRect.left = rect.left - body.left;
            newRect.top = rect.top - body.top;
            newRect.right = rect.right - body.left;
            newRect.bottom = rect.bottom - body.top;
            newRect.width = rect.width;
            newRect.height = rect.height;

            return newRect;
        }

        // (for interaction with accordion plugin)
        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // (for interaction with accordion plugin)
        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // (for interaction with accordion plugin)
        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- caret left icon -->

<template class="icon_caret_left">
    <!-- modified from: https://fontawesome.com/icons/caret-left -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M192 127.338v257.324c0 17.818-21.543 26.741-34.142 14.142L29.196 270.142c-7.81-7.81-7.81-20.474 0-28.284l128.662-128.662c12.599-12.6 34.142-3.676 34.142 14.142z"
        ></path>
    </svg>
</template>

<!-- caret right icon -->

<template class="icon_caret_right">
    <!-- modified from: https://fontawesome.com/icons/caret-right -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M0 384.662V127.338c0-17.818 21.543-26.741 34.142-14.142l128.662 128.662c7.81 7.81 7.81 20.474 0 28.284L34.142 398.804C21.543 411.404 0 402.48 0 384.662z"
        ></path>
    </svg>
</template>
<!-- jump to first plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin adds a button next to each reference entry,
        // figure, and table that jumps the page to the first occurrence of a
        // link to that item in the manuscript.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'jumpToFirst';

        // default plugin options
        const options = {
            // whether to add buttons next to reference entries
            references: 'true',
            // whether to add buttons next to figures
            figures: 'true',
            // whether to add buttons next to tables
            tables: 'true',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            if (options.references !== 'false')
                makeReferenceButtons();
            if (options.figures !== 'false')
                makeFigureButtons();
            if (options.tables !== 'false')
                makeTableButtons();
        }

        // when jump button clicked
        function onButtonClick() {
            const first = getFirstOccurrence(this.dataset.id);
            if (!first)
                return;

            // update url hash so navigating "back" in history will return
            // user to jump button
            window.location.hash = this.dataset.id;
            // scroll to link
            window.setTimeout(function() {
                goToElement(first, window.innerHeight * 0.5);
            }, 0);
        }

        // get first occurence of link to item in document
        function getFirstOccurrence(id) {
            let query = 'a';
            query += '[href="#' + id + '"]';
            // exclude buttons, anchor links, toc links, etc
            query +=
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            return document.querySelector(query);
        }

        // add button next to each reference entry
        function makeReferenceButtons() {
            const references = document.querySelectorAll('div[id^="ref-"]');
            for (const reference of references) {
                // get reference id and element to add button to
                const id = reference.id;
                const container = reference.firstElementChild;
                const first = getFirstOccurrence(id);

                // if can't find link to reference, ignore
                if (!first)
                    continue;

                // make jump button
                let button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this reference in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.innerHTML = button.outerHTML + container.innerHTML;
                button = container.firstElementChild;
                button.addEventListener('click', onButtonClick);
            }
        }

        // add button next to each figure
        function makeFigureButtons() {
            const figures = document.querySelectorAll('img[id^="fig:"]');
            for (const figure of figures) {
                // get figure id and element to add button to
                const id = figure.id;
                const container = figure.nextElementSibling;
                const first = getFirstOccurrence(id);

                // if can't find link to figure, ignore
                if (!first)
                    continue;

                // make jump button
                const button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this figure in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.insertBefore(button, container.firstElementChild);
                button.addEventListener('click', onButtonClick);
            }
        }

        // add button next to each figure
        function makeTableButtons() {
            const tables = document.querySelectorAll('a[name^="tbl:"]');
            for (const table of tables) {
                // get ref id and element to add button to
                const id = table.name;
                const container = table.nextElementSibling.querySelector(
                    'caption'
                );
                const first = getFirstOccurrence(id);

                // if can't find link to table, ignore
                if (!first)
                    continue;

                // make jump button
                const button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this table in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.insertBefore(button, container.firstElementChild);
                button.addEventListener('click', onButtonClick);
            }
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // (for interaction with accordion plugin)
        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- angle double up icon -->

<template class="icon_angle_double_up">
    <!-- modified from: https://fontawesome.com/icons/angle-double-up -->
    <svg width="16" height="16" viewBox="0 0 320 512">
        <path
            fill="currentColor"
            d="M177 255.7l136 136c9.4 9.4 9.4 24.6 0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9 0L160 351.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9 0L7 425.7c-9.4-9.4-9.4-24.6 0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1zm-34-192L7 199.7c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l96.4-96.4 96.4 96.4c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9l-136-136c-9.2-9.4-24.4-9.4-33.8 0z"
        ></path>
    </svg>
</template>
<!-- link highlight plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when a user hovers or
        // focuses a link, other links that have the same target will be
        // highlighted. It also makes it such that when clicking a link, the
        // target of the link (eg reference, figure, table) is briefly
        // highlighted.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'linkHighlight';

        // default plugin options
        const options = {
            // whether to also highlight links that go to external urls
            externalLinks: 'false',
            // whether user must click off to unhighlight instead of just
            // un-hovering
            clickUnhighlight: 'false',
            // whether to also highlight links that are unique
            highlightUnique: 'true',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            const links = getLinks();
            for (const link of links) {
                // attach mouse and focus listeners to link
                link.addEventListener('mouseenter', onLinkFocus);
                link.addEventListener('focus', onLinkFocus);
                link.addEventListener('mouseleave', onLinkUnhover);
            }

            // attach click and hash change listeners to window
            window.addEventListener('click', onClick);
            window.addEventListener('touchstart', onClick);
            window.addEventListener('hashchange', onHashChange);

            // run hash change on window load in case user has navigated
            // directly to hash
            onHashChange();
        }

        // when link is focused (tabbed to) or hovered
        function onLinkFocus() {
            highlight(this);
        }

        // when link is unhovered
        function onLinkUnhover() {
            if (options.clickUnhighlight !== 'true')
                unhighlightAll();
        }

        // when the mouse is clicked anywhere in window
        function onClick(event) {
            unhighlightAll();
        }

        // when hash (eg manuscript.html#introduction) changes
        function onHashChange() {
            const target = getHashTarget();
            if (target)
                glowElement(target);
        }

        // get element that is target of link or url hash
        function getHashTarget(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector(
                '[id="' + id + '"], [name="' + id + '"]'
            );
            if (!target)
                return;

            // if figure or table, modify target to get expected element
            if (hash.indexOf('#fig:') === 0)
                target = target.parentNode;
            else if (hash.indexOf('#tbl:') === 0)
                target = target.nextElementSibling.querySelector('caption');

            return target;
        }

        // start glow sequence on an element
        function glowElement(element) {
            const startGlow = function() {
                onGlowEnd();
                element.dataset.glow = 'true';
                element.addEventListener('animationend', onGlowEnd);
            };
            const onGlowEnd = function() {
                element.removeAttribute('data-glow');
                element.removeEventListener('animationend', onGlowEnd);
            };
            startGlow();
        }

        // highlight link and all others with same target
        function highlight(link) {
            // force unhighlight all to start fresh
            unhighlightAll();

            // get links with same target
            if (!link)
                return;
            const sameLinks = getSameLinks(link);

            // if link unique and option is off, exit and don't highlight
            if (sameLinks.length <= 1 && options.highlightUnique !== 'true')
                return;

            // highlight all same links, and "select" (special highlight) this
            // one
            for (const sameLink of sameLinks) {
                if (sameLink === link)
                    sameLink.setAttribute('data-selected', 'true');
                else
                    sameLink.setAttribute('data-highlighted', 'true');
            }
        }

        // unhighlight all links
        function unhighlightAll() {
            const links = getLinks();
            for (const link of links) {
                link.setAttribute('data-selected', 'false');
                link.setAttribute('data-highlighted', 'false');
            }
        }

        // get links with same target
        function getSameLinks(link) {
            const results = [];
            const links = getLinks();
            for (const otherLink of links) {
                if (
                    otherLink.getAttribute('href') === link.getAttribute('href')
                )
                    results.push(otherLink);
            }
            return results;
        }

        // get all links of types we wish to handle
        function getLinks() {
            let query = 'a';
            if (options.externalLinks !== 'true')
                query += '[href^="#"]';
            // exclude buttons, anchor links, toc links, etc
            query +=
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            return document.querySelectorAll(query);
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>
<!-- table of contents plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin provides a "table of contents" (toc) panel on
        // the side of the document that allows the user to conveniently
        // navigate between sections of the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'tableOfContents';

        // default plugin options
        const options = {
            // which types of elements to add links for, in
            // "document.querySelector" format
            typesQuery: 'h1, h2, h3',
            // whether default behavior is to be closed ('false'), open
            // ('true'), or only open when screen wide enough to fit panel
            // ('auto'). note: still always starts closed when page loads.
            open: 'auto',
            // if list item is more than this many characters, text will be
            // truncated
            charLimit: '50',
            // whether or not to show bullets next to each toc item
            bullets: 'false',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // make toc panel and populate with entries (links to document
            // sections)
            const panel = makePanel();
            if (!panel)
                return;
            makeEntries(panel);
            document.body.insertBefore(panel, document.body.firstChild);

            closePanel();

            // attach click, scroll, and hash change listeners to window
            window.addEventListener('click', onClick);
            window.addEventListener('touchstart', onClick);
            window.addEventListener('scroll', onScroll);
            window.addEventListener('hashchange', onScroll);
            window.addEventListener('keyup', onKeyUp);
            onScroll();

            // add class to push document body down out of way of toc button
            document.body.classList.add('toc_body_nudge');
        }

        // determine if screen wide enough to fit toc panel
        function isSmallScreen() {
            // in default theme:
            // 816px = 8.5in = width of "page" (<body>) element
            // 260px = min width of toc panel (*2 for both sides of <body>)
            return window.innerWidth < 816 + 260 * 2;
        }

        // open/close panel based on option and screen size
        function openOrClosePanel() {
            if (
                options.open === 'true' ||
                (options.open === 'auto' && !isSmallScreen())
            )
                openPanel();
            else
                closePanel();
        }

        // when mouse is clicked anywhere in window
        function onClick() {
            const panel = document.getElementById('toc_panel');
            if (!panel)
                return;

            if (panel.dataset.open === 'true')
                openOrClosePanel();
        }

        // when window is scrolled or hash changed
        function onScroll() {
            highlightViewed();
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            // close on esc
            if (event.key === 'Escape')
                closePanel();
        }

        // find entry of currently viewed document section in toc and highlight
        function highlightViewed() {
            const firstId = getFirstInView(options.typesQuery);

            // get toc entries (links), unhighlight all, then highlight viewed
            const list = document.getElementById('toc_list');
            if (!firstId || !list)
                return;
            const links = list.querySelectorAll('a');
            for (const link of links)
                link.dataset.viewing = 'false';
            const link = list.querySelector('a[href="#' + firstId + '"]');
            if (!link)
                return;
            link.dataset.viewing = 'true';
        }

        // get first or previous toc listed element in top half of view
        function getFirstInView(query) {
            // get all elements matching query and with id
            const elements = document.querySelectorAll(query);
            const elementsWithIds = [];
            for (const element of elements) {
                if (element.id)
                    elementsWithIds.push(element);
            }


            // get first or previous element in top half of view
            for (let i = 0; i < elementsWithIds.length; i++) {
                const element = elementsWithIds[i];
                const prevElement = elementsWithIds[Math.max(0, i - 1)];
                if (element.getBoundingClientRect().top >= 0) {
                    if (
                        element.getBoundingClientRect().top <
                        window.innerHeight / 2
                    )
                        return element.id;
                    else
                        return prevElement.id;
                }
            }
        }

        // make panel
        function makePanel() {
            // create panel
            const panel = document.createElement('div');
            panel.id = 'toc_panel';
            if (options.bullets === 'true')
                panel.dataset.bullets = 'true';

            // create header
            const header = document.createElement('div');
            header.id = 'toc_header';

            // create toc button
            const button = document.createElement('button');
            button.id = 'toc_button';
            button.innerHTML = document.querySelector(
                '.icon_th_list'
            ).innerHTML;
            button.classList.add('icon_button');

            // create header text
            const text = document.createElement('h3');
            text.innerHTML = 'Table of Contents';

            // create container for toc list
            const list = document.createElement('div');
            list.id = 'toc_list';

            // attach click listeners
            panel.addEventListener('click', onPanelClick);
            header.addEventListener('click', onHeaderClick);
            button.addEventListener('click', onButtonClick);

            // attach elements
            header.appendChild(button);
            header.appendChild(text);
            panel.appendChild(header);
            panel.appendChild(list);

            return panel;
        }

        // create toc entries (links) to each element of the specified types
        function makeEntries(panel) {
            const elements = document.querySelectorAll(options.typesQuery);
            for (const element of elements) {
                // do not add link if element doesn't have assigned id
                if (!element.id)
                    continue;

                // create link/list item
                const link = document.createElement('a');
                link.classList.add('toc_link');
                switch (element.tagName.toLowerCase()) {
                    case 'h1':
                        link.dataset.level = '1';
                        break;
                    case 'h2':
                        link.dataset.level = '2';
                        break;
                    case 'h3':
                        link.dataset.level = '3';
                        break;
                    case 'h4':
                        link.dataset.level = '4';
                        break;
                }
                link.title = element.innerText;
                let text = element.innerText;
                if (text.length > options.charLimit)
                    text = text.slice(0, options.charLimit) + '...';
                link.innerHTML = text;
                link.href = '#' + element.id;
                link.addEventListener('click', onLinkClick);

                // attach link
                panel.querySelector('#toc_list').appendChild(link);
            }
        }

        // when panel is clicked
        function onPanelClick(event) {
            // stop click from propagating to window/document and closing panel
            event.stopPropagation();
        }

        // when header itself is clicked
        function onHeaderClick(event) {
            togglePanel();
        }

        // when button is clicked
        function onButtonClick(event) {
            togglePanel();
            // stop header underneath button from also being clicked
            event.stopPropagation();
        }

        // when link is clicked
        function onLinkClick() {
            openOrClosePanel();
        }

        // open panel if closed, close if opened
        function togglePanel() {
            const panel = document.getElementById('toc_panel');
            if (!panel)
                return;

            if (panel.dataset.open === 'true')
                closePanel();
            else
                openPanel();
        }

        // open panel
        function openPanel() {
            const panel = document.getElementById('toc_panel');
            if (panel)
                panel.dataset.open = 'true';
        }

        // close panel
        function closePanel() {
            const panel = document.getElementById('toc_panel');
            if (panel)
                panel.dataset.open = 'false';
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- th list icon -->

<template class="icon_th_list">
    <!-- modified from: https://fontawesome.com/icons/th-list -->
    <svg width="16" height="16" viewBox="0 0 512 512" tabindex="-1">
        <path
            fill="currentColor"
            d="M96 96c0 26.51-21.49 48-48 48S0 122.51 0 96s21.49-48 48-48 48 21.49 48 48zM48 208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm0 160c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm96-236h352c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h352c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h352c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"
            tabindex="-1"
        ></path>
    </svg>
</template>
<!-- lightbox plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when a user clicks on an
        // image, the image fills the screen and the user can pan/drag/zoom
        // the image and navigate between other images in the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'lightbox';

        // default plugin options
        const options = {
            // list of possible zoom/scale factors
            zoomSteps:
                '0.1, 0.25, 0.333333, 0.5, 0.666666, 0.75, 1,' +
                '1.25, 1.5, 1.75, 2, 2.5, 3, 3.5, 4, 5, 6, 7, 8',
            // whether to fit image to view ('fit'), display at 100% and shrink
            // if necessary ('shrink'), or always display at 100% ('100')
            defaultZoom: 'fit',
            // whether to zoom in/out toward center of view ('true') or mouse
            // ('false')
            centerZoom: 'false',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // run through each <img> element
            const imgs = document.querySelectorAll('figure > img');
            let count = 1;
            for (const img of imgs) {
                img.classList.add('lightbox_document_img');
                img.dataset.number = count;
                img.dataset.total = imgs.length;
                img.addEventListener('click', openLightbox);
                count++;
            }

            // attach mouse and key listeners to window
            window.addEventListener('mousemove', onWindowMouseMove);
            window.addEventListener('keyup', onKeyUp);
        }

        // when mouse is moved anywhere in window
        function onWindowMouseMove(event) {
            window.mouseX = event.clientX;
            window.mouseY = event.clientY;
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            switch (event.key) {
                // trigger click of prev button
                case 'ArrowLeft':
                    const prevButton = document.getElementById(
                        'lightbox_prev_button'
                    );
                    if (prevButton)
                        prevButton.click();
                    break;
                // trigger click of next button
                case 'ArrowRight':
                    const nextButton = document.getElementById(
                        'lightbox_next_button'
                    );
                    if (nextButton)
                        nextButton.click();
                    break;
                // close on esc
                case 'Escape':
                    closeLightbox();
                    break;
            }
        }

        // open lightbox
        function openLightbox() {
            const lightbox = makeLightbox(this);
            if (!lightbox)
                return;

            blurBody(lightbox);
            document.body.appendChild(lightbox);
        }

        // make lightbox
        function makeLightbox(img) {
            // delete lightbox if it exists, start fresh
            closeLightbox();

            // create screen overlay containing lightbox
            const overlay = document.createElement('div');
            overlay.id = 'lightbox_overlay';

            // create image info boxes
            const numberInfo = document.createElement('div');
            const zoomInfo = document.createElement('div');
            numberInfo.id = 'lightbox_number_info';
            zoomInfo.id = 'lightbox_zoom_info';

            // create container for image
            const imageContainer = document.createElement('div');
            imageContainer.id = 'lightbox_image_container';
            const lightboxImg = makeLightboxImg(
                img,
                imageContainer,
                numberInfo,
                zoomInfo
            );
            imageContainer.appendChild(lightboxImg);

            // create bottom container for caption and navigation buttons
            const bottomContainer = document.createElement('div');
            bottomContainer.id = 'lightbox_bottom_container';
            const caption = makeCaption(img);
            const prevButton = makePrevButton(img);
            const nextButton = makeNextButton(img);
            bottomContainer.appendChild(prevButton);
            bottomContainer.appendChild(caption);
            bottomContainer.appendChild(nextButton);

            // attach top middle and bottom to overlay
            overlay.appendChild(numberInfo);
            overlay.appendChild(zoomInfo);
            overlay.appendChild(imageContainer);
            overlay.appendChild(bottomContainer);

            return overlay;
        }

        // make <img> object that is intuitively draggable and zoomable
        function makeLightboxImg(
            sourceImg,
            container,
            numberInfoBox,
            zoomInfoBox
        ) {
            // create copy of source <img>
            const img = sourceImg.cloneNode(true);
            img.classList.remove('lightbox_document_img');
            img.removeAttribute('id');
            img.removeAttribute('width');
            img.removeAttribute('height');
            img.style.position = 'unset';
            img.style.margin = '0';
            img.style.padding = '0';
            img.style.width = '';
            img.style.height = '';
            img.style.minWidth = '';
            img.style.minHeight = '';
            img.style.maxWidth = '';
            img.style.maxHeight = '';
            img.id = 'lightbox_img';

            // build sorted list of unique zoomSteps, always including a 100%
            let zoomSteps = [];
            const optionsZooms = options.zoomSteps.split(/[^0-9.]/);
            for (const optionZoom of optionsZooms) {
                const newZoom = parseFloat(optionZoom);
                if (newZoom && !zoomSteps.includes(newZoom))
                    zoomSteps.push(newZoom);
            }
            if (!zoomSteps.includes(1))
                zoomSteps.push(1);
            zoomSteps = zoomSteps.sort(function sortNumber(a, b) {
                return a - b;
            });

            // <img> object property variables
            let zoom = 1;
            let translateX = 0;
            let translateY = 0;
            let clickMouseX = undefined;
            let clickMouseY = undefined;
            let clickTranslateX = undefined;
            let clickTranslateY = undefined;

            updateNumberInfo();

            // update image numbers displayed in info box
            function updateNumberInfo() {
                numberInfoBox.innerHTML =
                    sourceImg.dataset.number + ' of ' + sourceImg.dataset.total;
            }

            // update zoom displayed in info box
            function updateZoomInfo() {
                let zoomInfo = zoom * 100;
                if (!Number.isInteger(zoomInfo))
                    zoomInfo = zoomInfo.toFixed(2);
                zoomInfoBox.innerHTML = zoomInfo + '%';
            }

            // move to closest zoom step above current zoom
            const zoomIn = function() {
                for (const zoomStep of zoomSteps) {
                    if (zoomStep > zoom) {
                        zoom = zoomStep;
                        break;
                    }
                }
                updateTransform();
            };

            // move to closest zoom step above current zoom
            const zoomOut = function() {
                zoomSteps.reverse();
                for (const zoomStep of zoomSteps) {
                    if (zoomStep < zoom) {
                        zoom = zoomStep;
                        break;
                    }
                }
                zoomSteps.reverse();

                updateTransform();
            };

            // update display of <img> based on scale/translate properties
            const updateTransform = function() {
                // set transform
                img.style.transform =
                    'translate(' +
                    (translateX || 0) +
                    'px,' +
                    (translateY || 0) +
                    'px) scale(' +
                    (zoom || 1) +
                    ')';

                // get new width/height after scale
                const rect = img.getBoundingClientRect();
                // limit translate
                translateX = Math.max(translateX, -rect.width / 2);
                translateX = Math.min(translateX, rect.width / 2);
                translateY = Math.max(translateY, -rect.height / 2);
                translateY = Math.min(translateY, rect.height / 2);

                // set transform
                img.style.transform =
                    'translate(' +
                    (translateX || 0) +
                    'px,' +
                    (translateY || 0) +
                    'px) scale(' +
                    (zoom || 1) +
                    ')';

                updateZoomInfo();
            };

            // fit <img> to container
            const fit = function() {
                // no x/y offset, 100% zoom by default
                translateX = 0;
                translateY = 0;
                zoom = 1;

                // widths of <img> and container
                const imgWidth = img.naturalWidth;
                const imgHeight = img.naturalHeight;
                const containerWidth = parseFloat(
                    window.getComputedStyle(container).width
                );
                const containerHeight = parseFloat(
                    window.getComputedStyle(container).height
                );

                // how much zooming is needed to fit <img> to container
                const xRatio = imgWidth / containerWidth;
                const yRatio = imgHeight / containerHeight;
                const maxRatio = Math.max(xRatio, yRatio);
                const newZoom = 1 / maxRatio;

                // fit <img> to container according to option
                if (options.defaultZoom === 'shrink') {
                    if (maxRatio > 1)
                        zoom = newZoom;
                } else if (options.defaultZoom === 'fit')
                    zoom = newZoom;

                updateTransform();
            };

            // when mouse wheel is rolled anywhere in container
            const onContainerWheel = function(event) {
                if (!event)
                    return;

                // let ctrl + mouse wheel to zoom behave as normal
                if (event.ctrlKey)
                    return;

                // prevent normal scroll behavior
                event.preventDefault();
                event.stopPropagation();

                // point around which to scale img
                const viewRect = container.getBoundingClientRect();
                const viewX = (viewRect.left + viewRect.right) / 2;
                const viewY = (viewRect.top + viewRect.bottom) / 2;
                const originX = options.centerZoom === 'true' ? viewX : mouseX;
                const originY = options.centerZoom === 'true' ? viewY : mouseY;

                // get point on image under origin
                const oldRect = img.getBoundingClientRect();
                const oldPercentX = (originX - oldRect.left) / oldRect.width;
                const oldPercentY = (originY - oldRect.top) / oldRect.height;

                // increment/decrement zoom
                if (event.deltaY < 0)
                    zoomIn();
                if (event.deltaY > 0)
                    zoomOut();

                // get offset between previous image point and origin
                const newRect = img.getBoundingClientRect();
                const offsetX =
                    originX - (newRect.left + newRect.width * oldPercentX);
                const offsetY =
                    originY - (newRect.top + newRect.height * oldPercentY);

                // translate image to keep image point under origin
                translateX += offsetX;
                translateY += offsetY;

                // perform translate
                updateTransform();
            };

            // when container is clicked
            function onContainerClick(event) {
                // if container itself is target of click, and not other
                // element above it
                if (event.target === this)
                    closeLightbox();
            }

            // when mouse button is pressed on image
            const onImageMouseDown = function(event) {
                // store original mouse position relative to image
                clickMouseX = window.mouseX;
                clickMouseY = window.mouseY;
                clickTranslateX = translateX;
                clickTranslateY = translateY;
                event.stopPropagation();
                event.preventDefault();
            };

            // when mouse button is released anywhere in window
            const onWindowMouseUp = function(event) {
                // reset original mouse position
                clickMouseX = undefined;
                clickMouseY = undefined;
                clickTranslateX = undefined;
                clickTranslateY = undefined;

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('mouseup', onWindowMouseUp);
            };

            // when mouse is moved anywhere in window
            const onWindowMouseMove = function(event) {
                if (
                    clickMouseX === undefined ||
                    clickMouseY === undefined ||
                    clickTranslateX === undefined ||
                    clickTranslateY === undefined
                )
                    return;

                // offset image based on original and current mouse position
                translateX = clickTranslateX + window.mouseX - clickMouseX;
                translateY = clickTranslateY + window.mouseY - clickMouseY;
                updateTransform();
                event.preventDefault();

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('mousemove', onWindowMouseMove);
            };

            // when window is resized
            const onWindowResize = function(event) {
                fit();

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('resize', onWindowResize);
            };

            // attach the necessary event listeners
            img.addEventListener('dblclick', fit);
            img.addEventListener('mousedown', onImageMouseDown);
            container.addEventListener('wheel', onContainerWheel);
            container.addEventListener('mousedown', onContainerClick);
            container.addEventListener('touchstart', onContainerClick);
            window.addEventListener('mouseup', onWindowMouseUp);
            window.addEventListener('mousemove', onWindowMouseMove);
            window.addEventListener('resize', onWindowResize);

            // run fit() after lightbox atttached to document and <img> Loaded
            // so needed container and img dimensions available
            img.addEventListener('load', fit);

            return img;
        }

        // make caption
        function makeCaption(img) {
            const caption = document.createElement('div');
            caption.id = 'lightbox_caption';
            const captionSource = img.nextElementSibling;
            if (captionSource.tagName.toLowerCase() === 'figcaption') {
                const captionCopy = makeCopy(captionSource);
                caption.innerHTML = captionCopy.innerHTML;
            }

            caption.addEventListener('touchstart', function(event) {
                event.stopPropagation();
            });

            return caption;
        }

        // make carbon copy of html dom element
        function makeCopy(source) {
            const sourceCopy = source.cloneNode(true);

            // delete elements marked with ignore (eg anchor and jump buttons)
            const deleteFromCopy = sourceCopy.querySelectorAll(
                '[data-ignore="true"]'
            );
            for (const element of deleteFromCopy)
                element.remove();

            // delete certain element attributes
            const attributes = [
                'id',
                'data-collapsed',
                'data-selected',
                'data-highlighted',
                'data-glow'
            ];
            for (const attribute of attributes) {
                sourceCopy.removeAttribute(attribute);
                const elements = sourceCopy.querySelectorAll(
                    '[' + attribute + ']'
                );
                for (const element of elements)
                    element.removeAttribute(attribute);
            }

            return sourceCopy;
        }

        // make button to jump to previous image in document
        function makePrevButton(img) {
            const prevButton = document.createElement('button');
            prevButton.id = 'lightbox_prev_button';
            prevButton.title = 'Jump to the previous image in the document [←]';
            prevButton.classList.add('icon_button', 'lightbox_button');
            prevButton.innerHTML = document.querySelector(
                '.icon_caret_left'
            ).innerHTML;

            // attach click listeners to button
            prevButton.addEventListener('click', function() {
                getPrevImg(img).click();
            });

            return prevButton;
        }

        // make button to jump to next image in document
        function makeNextButton(img) {
            const nextButton = document.createElement('button');
            nextButton.id = 'lightbox_next_button';
            nextButton.title = 'Jump to the next image in the document [→]';
            nextButton.classList.add('icon_button', 'lightbox_button');
            nextButton.innerHTML = document.querySelector(
                '.icon_caret_right'
            ).innerHTML;

            // attach click listeners to button
            nextButton.addEventListener('click', function() {
                getNextImg(img).click();
            });

            return nextButton;
        }

        // get previous image in document
        function getPrevImg(img) {
            const imgs = document.querySelectorAll('.lightbox_document_img');

            // find index of provided img
            let index;
            for (index = 0; index < imgs.length; index++) {
                if (imgs[index] === img)
                    break;
            }


            // wrap index to other side if < 1
            if (index - 1 >= 0)
                index--;
            else
                index = imgs.length - 1;
            return imgs[index];
        }

        // get next image in document
        function getNextImg(img) {
            const imgs = document.querySelectorAll('.lightbox_document_img');

            // find index of provided img
            let index;
            for (index = 0; index < imgs.length; index++) {
                if (imgs[index] === img)
                    break;
            }


            // wrap index to other side if > total
            if (index + 1 <= imgs.length - 1)
                index++;
            else
                index = 0;
            return imgs[index];
        }

        // close lightbox
        function closeLightbox() {
            focusBody();

            const lightbox = document.getElementById('lightbox_overlay');
            if (lightbox)
                lightbox.remove();
        }

        // make all elements behind lightbox non-focusable
        function blurBody(overlay) {
            const all = document.querySelectorAll('*');
            for (const element of all)
                element.tabIndex = -1;
            document.body.classList.add('body_no_scroll');
        }

        // make all elements focusable again
        function focusBody() {
            const all = document.querySelectorAll('*');
            for (const element of all)
                element.removeAttribute('tabIndex');
            document.body.classList.remove('body_no_scroll');
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- caret left icon -->

<template class="icon_caret_left">
    <!-- modified from: https://fontawesome.com/icons/caret-left -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M192 127.338v257.324c0 17.818-21.543 26.741-34.142 14.142L29.196 270.142c-7.81-7.81-7.81-20.474 0-28.284l128.662-128.662c12.599-12.6 34.142-3.676 34.142 14.142z"
        ></path>
    </svg>
</template>

<!-- caret right icon -->

<template class="icon_caret_right">
    <!-- modified from: https://fontawesome.com/icons/caret-right -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M0 384.662V127.338c0-17.818 21.543-26.741 34.142-14.142l128.662 128.662c7.81 7.81 7.81 20.474 0 28.284L34.142 398.804C21.543 411.404 0 402.48 0 384.662z"
        ></path>
    </svg>
</template>
<!-- attributes plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin allows arbitrary HTML attributes to be attached
        // to (almost) any element. Place an HTML comment inside or next to the
        // desired element in the format <!-- $attribute="value" -->

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'attributes';

        // default plugin options
        const options = {
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // get list of comments in document
            const comments = findComments();

            for(const comment of comments)
                if (comment.parentElement)
                    addAttributes(
                        comment.parentElement,
                        comment.nodeValue.trim()
                    );
        }

        // add html attributes to specified element based on string of 
        // html attributes and values
        function addAttributes(element, text) {
            // regex's for finding attribute/value pairs in the format of
            // attribute="value" or attribute='value
            const regex2 = /\$([a-zA-Z\-]+)?=\"(.+?)\"/;
            const regex1 = /\$([a-zA-Z\-]+)?=\'(.+?)\'/;

            // loop through attribute/value pairs
            let match;
            while(match = text.match(regex2) || text.match(regex1)) {
                // get attribute and value from regex capture groups
                let attribute = match[1];
                let value = match[2];

                // remove from string
                text = text.substring(match.index + match[0].length);

                if (!attribute || !value)
                    break;

                // set attribute of parent element
                try {
                    element.setAttribute(attribute, value);
                } catch(error) {
                    console.log(error);
                }

                // special case for colspan
                if (attribute === 'colspan')
                    removeTableCells(element, value);
            }
        }

        // get list of comment elements in document
        function findComments() {
            const comments = [];

            // iterate over comment nodes in document
            function acceptNode(node) {
                return NodeFilter.FILTER_ACCEPT;
            }
            const iterator = document.createNodeIterator(
                document.body,
                NodeFilter.SHOW_COMMENT,
                acceptNode
            );
            let node;
            while(node = iterator.nextNode())
                comments.push(node);

            return comments;
        }

        // remove certain number of cells after specified cell
        function removeTableCells(cell, number) {
            number = parseInt(number);
            if (!number)
                return;

            // remove elements
            for(; number > 1; number--) {
                if (cell.nextElementSibling)
                    cell.nextElementSibling.remove();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>
<!-- math plugin configuration -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        "CommonHTML": { linebreaks: { automatic: true } },
        "HTML-CSS": { linebreaks: { automatic: true } },
        "SVG": { linebreaks: { automatic: true } },
        "fast-preview": { disabled: true }
    });
</script>

<!-- math plugin -->

<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML'>
    // /////////////////////////
    // DESCRIPTION
    // /////////////////////////

    // This third-party plugin 'MathJax' allows the proper rendering of
    // math/equations written in LaTeX.

    // https://www.mathjax.org/
</script>
<!-- annotations plugin configuration -->

<script>
    window.hypothesisConfig = function() {
        return {
            branding: {
                accentColor: '#2196f3',
                appBackgroundColor: '#f8f8f8',
                ctaBackgroundColor: '#f8f8f8',
                ctaTextColor: '#000000',
                selectionFontFamily: 'Open Sans, Helvetica, sans serif',
                annotationFontFamily: 'Open Sans, Helvetica, sans serif'
            }
        };
    };
</script>

<!-- annotations plugin -->

<script src='https://hypothes.is/embed.js'>
    // /////////////////////////
    // DESCRIPTION
    // /////////////////////////

    // This third-party plugin 'Hypothesis' allows public annotation of the
    // manuscript.

    // https://web.hypothes.is/
</script>
<!-- analytics plugin -->

<!-- copy and paste code from Google Analytics or similar service here -->
</body>
</html>
